------------------------------------------------------------------------------------
--@header 
--@doc Copyright Leo Freitas 2019-2020 
--@v40, 31/11/2020
--@doc International Standard of Quantities and Units
--@doc inspired by ISQ (https://en.wikipedia.org/wiki/International_System_of_Units) 
--	   encoding in Isabelle (https://www.isa-afp.org/entries/Physical_Quantities.html)
--	   simplified to consider just time, with hours as the base unit of time.
--@todo conversions map yet to be created/used; just exported for now.
------------------------------------------------------------------------------------
module ISQ
imports
from MATH
	functions
		pi_f renamed pi_f;
,
from VDMUtil
	functions
		val2seq_of_char renamed val2seq_of_char;
,
from Support1
	types 
		String renamed String;
		String1 renamed String1;
	functions
		fold renamed fold;
		prods_r renamed prods_r;
		averages_r renamed averages_r;
		replicate renamed replicate;
exports 
	types
		--@todo which ones to struct export which not to?
		struct Dimension;
		struct DimensionlessVector;
		struct DimensionVector;
		struct DimensionView;
		struct SingleDimension;
		struct Magnitude;
		struct MagnitudeN0;
		struct Magnitude1;
		struct Quantity;
		struct QuantityN0;
		struct SQuantity;
		struct SQuantityN0;
		struct ConversionSchema;
		
		--@todo make use of those
		struct Conversion;
		struct Conversions;

		struct MeasurementSystem;	
		struct MeasurementSystemN0;
		struct Prefix;	
	
		struct Second;

		struct SI_MeasurementSystem;
		struct Meter;
		struct Kilogram;
		struct Ampere;
		struct Kelvin;
		struct Mole;
		struct Candela;

		struct Area;
		struct Volume;
		struct Frequency;
		struct Velocity;
		struct Acceleration;
		struct Energy;
		struct Power;
		struct Force;
		struct Pressure;
		struct Charge;
		struct PotentialDifference;
		struct Capacitance;
		struct Hertz;
		struct Watt;
		struct Radian;
		struct Steradian;

		struct BIS_MeasurementSystem;
		struct Yard;
		struct Pound;
		struct Rankine;
		struct BISVolume;
		struct BISVelocity;

		struct CGS_MeasurementSystem;
		struct Centimetre;
		struct Gram;
		
		struct MHC_MeasurementSystem;
		struct Milligram;
		struct Hour;
		struct Celcius;

		struct WhichMonth;
		struct HowManyDays;
	
		struct MDC_MeasurementSystem;
		struct Day;
		
		struct MWC_MeasurementSystem;
		struct Week;
	
	functions
		dim_comp: DimensionlessVector * DimensionlessVector -> DimensionlessVector;
		dim_comp_n: DimensionlessVector * nat -> DimensionlessVector;
		dim_inv: DimensionlessVector -> DimensionlessVector;
		dim_inv_n: DimensionlessVector * nat1 -> DimensionlessVector;
		dim_div: DimensionlessVector * DimensionlessVector -> DimensionlessVector;
		dim_view: DimensionView * DimensionlessVector -> String1;
		si_dim_view: Prefix -> String1;
		bis_dim_view: Prefix -> String1;
	
		quant_dim_eq: Quantity * Quantity -> bool;
		quant_times: Quantity * Quantity -> Quantity;
		quant_div: Quantity * QuantityN0 -> Quantity;
		quant_inv: QuantityN0 -> Quantity;
		quant_itself_n: Quantity * nat1 -> Quantity;
		quant_inv_n: QuantityN0 * nat1 -> Quantity;
		quant_plus: Quantity * Quantity -> Quantity;
		quant_uminus: Quantity -> Quantity;
		quant_minus: Quantity * Quantity -> Quantity;
		scaleQ: Magnitude * Quantity -> Quantity;

		scaleMS: Magnitude * MeasurementSystem -> MeasurementSystem;
		quant_conv: ConversionSchema * DimensionlessVector -> MagnitudeN0;
		conv_inv: ConversionSchema -> ConversionSchema;
		conv_comp: ConversionSchema * ConversionSchema -> ConversionSchema;
		ms_conv_eq: MeasurementSystem * MeasurementSystem -> bool;
		ms_times: MeasurementSystem * MeasurementSystem -> MeasurementSystem;
		ms_itself_n: MeasurementSystem * nat1 -> MeasurementSystem;
		ms_inv_n: MeasurementSystemN0 * nat1 -> MeasurementSystem;
		ms_inv: MeasurementSystemN0 -> MeasurementSystem;
		ms_div: MeasurementSystem * MeasurementSystemN0 -> MeasurementSystem;
		
		ms_quant_conv: ConversionSchema * MeasurementSystem -> MeasurementSystem;
		ms_conv: /*ConversionSchema * ConversionSchema * MeasurementSystem*/
						 MeasurementSystem * ConversionSchema -> MeasurementSystem;

		mag  : Prefix -> Magnitude;
		deca : Prefix -> Prefix;
		hecto: Prefix -> Prefix;
		kilo : Prefix -> Prefix;
		mega : Prefix -> Prefix;
		giga : Prefix -> Prefix;
		tera : Prefix -> Prefix;
		deci : Prefix -> Prefix;
		centi: Prefix -> Prefix;
		milli: Prefix -> Prefix;
		micro: Prefix -> Prefix;
		nano : Prefix -> Prefix;
		pico : Prefix -> Prefix;
	
		second: ConversionSchema * UnitSystem -> Second;
		minute: ConversionSchema * UnitSystem -> Second;
		hour  : ConversionSchema * UnitSystem -> Second;
		day   : ConversionSchema * UnitSystem -> Second;
		week  : ConversionSchema * UnitSystem -> Second;

		metrify: MeasurementSystem -> Quantity;
		SI_ASTRONOMICAL     : () -> Meter;
		SI_DEGREE           : () -> Radian;
		SI_LITRE            : () -> Volume;
		SI_TONNE            : () -> Kilogram;
		SI_YARD             : () -> Meter;
		SI_FOOT             : () -> Meter;
		SI_INCH             : () -> Meter;
		SI_MILE             : () -> Meter;
		SI_NAUTICAL_MILE    : () -> Meter;
		SI_POUND            : () -> Kilogram;
		SI_OUNCE            : () -> Kilogram;
		SI_STONE            : () -> Kilogram;
		SI_KNOT             : () -> Velocity;
		SI_MPH              : () -> Velocity;
		SI_MPS              : () -> Velocity;
		SI_KPH              : () -> Velocity;
		SI_PINT             : () -> Volume;
		SI_GALLON           : () -> Volume;
		SI_DEGREES_FARENHEIT: Magnitude -> Kelvin;
		SI_JOULE			: () -> SI_MeasurementSystem;
		SI_COLOUMB			: () -> SI_MeasurementSystem;
		SI_LUMEN			: () -> SI_MeasurementSystem;

		imperialise: MeasurementSystem -> Quantity;
		BIS_FOOT         : () -> Yard;
		BIS_INCH         : () -> Yard;
		BIS_MILE         : () -> Yard;
		BIS_ACRE         : () -> BISVolume;
		BIS_OUNCE        : () -> Pound;
		BIS_GALLON       : () -> BISVolume;
		BIS_PINT         : () -> BISVolume;
		BIS_MILE_PER_HOUR: () -> BISVelocity;

		hDAY      : () -> Hour;
		hWEEK     : () -> Hour;
		hMONTH    : WhichMonth -> Hour; 
		hAVG_MONTH: () -> Hour;
		hYEAR     : () -> Hour;
		weeks2months_hrs: nat1 -> Hour;
		n_times_day2every_x_hours: nat1 -> real;
	 		
		dWEEK: () -> Day;
		weeks2days: nat1 -> Day;

		wDAY      : () -> Week;
		wAVG_MONTH: () -> Week;
		weeks2months_wks: nat1 -> Week;

		approx: Magnitude * nat -> Magnitude;
		approx_eq: Magnitude * Magnitude * nat -> bool;
		mph2mps: Magnitude -> Magnitude;

		MEASUREMENT_SYSTEMS: () -> set1 of MeasurementSystem; 
		CONVERSION_SCHEMAS : () -> set1 of ConversionSchema;
		DIMENSION_VECTORS  : () -> set1 of DimensionlessVector;
		
	values
		DIMENSIONS 	     : set1 of Dimension;
		ZERO_DV          : DimensionlessVector;
		DLENGTH          : SingleDimension;
		DMASS            : SingleDimension;
		DTIME            : SingleDimension;
		DCURRENT         : SingleDimension;
		DTEMP            : SingleDimension;
		DAMOUNT          : SingleDimension;
		DINTENSITY       : SingleDimension;
		                
		DAREA            : DimensionVector; 
		DVOLUME          : DimensionVector; 
		DFREQUENCY       : DimensionVector; 
		DVELOCITY        : DimensionVector; 
		DACCELERATION    : DimensionVector; 
		DENERGY          : DimensionVector; 
		DPOWER           : DimensionVector; 
		DFORCE           : DimensionVector; 
		DPRESSURE        : DimensionVector; 
		DCHARGE          : DimensionVector; 
		DPDIFFERENCE     : DimensionVector; 
		DCAPACITANCE	 : DimensionVector; 
		DWATT            : DimensionVector; 
		DRADIAN          : DimensionlessVector;
		DSTERADIAN       : DimensionlessVector;

		SI_DIM_VIEW		 : DimensionView;
		BIS_DIM_VIEW	 : DimensionView;
		                 
		CONV_ID          : ConversionSchema;

		UNIT_LENGTH      : IntQuantity; 
		UNIT_MASS        : IntQuantity; 
		UNIT_TIME        : IntQuantity; 
		UNIT_CURRENT     : IntQuantity; 
		UNIT_TEMP        : IntQuantity; 
		UNIT_AMOUNT      : IntQuantity; 
		UNIT_INTENSITY   : IntQuantity; 

		UNIT_AREA        : Quantity;
    	UNIT_VOLUME      : Quantity;
    	UNIT_FREQUENCY   : Quantity;
		UNIT_VELOCITY    : Quantity;
		UNIT_ACCELERATION: Quantity;
		UNIT_ENERGY      : Quantity;
		UNIT_POWER       : Quantity;
		UNIT_FORCE       : Quantity;
		UNIT_PRESSURE    : Quantity;
		UNIT_CHARGE      : Quantity;
		UNIT_PDIFFERENCE : Quantity;
		UNIT_CAPACITANCE : Quantity;

		UNIT_RADIAN      : Quantity;
		UNIT_STERADIAN   : Quantity;
		UNIT_WATT        : Quantity;
	
		SI  	         : ConversionSchema;   
		METER            : Meter   ;
		KILOGRAM         : Kilogram;
		SECOND	         : Second  ;
		AMPERE           : Ampere  ;
		KELVIN           : Kelvin  ;
		MOLE             : Mole    ;
		CANDELA          : Candela ;
		                 
		SI_AREA          : Area        ;
		SI_VOLUME        : Volume      ;
		SI_FREQUENCY     : Frequency   ;
		SI_VELOCITY      : Velocity    ;
		SI_ACCELERATION  : Acceleration;
		SI_ENERGY        : Energy      ;
		SI_POWER         : Power       ;
		SI_FORCE         : Force       ;
		SI_PRESSURE      : Pressure    ;
		SI_CHARGE        : Charge      ;
		SI_PDIFFERENCE   : PotentialDifference;
		SI_CAPACITANCE	 : Capacitance ;
		SI_WATT			 : Watt		   ;
		SI_RADIAN		 : Radian	   ;
		SI_STERADIAN     : Steradian   ;

		BIS 	         : ConversionSchema;
		BIS_YARD	     : Yard    ;
		BIS_POUND        : Pound   ;
		BIS_RANKINE      : Rankine ;
		BIS_VOLUME       : BISVolume;
        BIS_VELOCITY	 : BISVelocity;

		CGS              : ConversionSchema;
		CENTIMETRE       : Centimetre;
		GRAM             : Gram			;
                     
		MHC              : ConversionSchema;
		MGRAM		     : Milligram;
		MHOUR            : Hour 		; 
		MCELCIUS         : Celcius ;	

		MDC				 : ConversionSchema;
		MDAY 			 : Day;
                     
		MWC			     : ConversionSchema;
		MWEEK		     : Week;

		HOURS_PER_DAY    : nat1;
		DAYS_PER_WEEK    : nat1;
		WEEKS_PER_YEAR   : nat1;
		MONTHS_PER_YEAR  : nat1;
		DAYS_PER_MONTH   : map WhichMonth to HowManyDays;
		
		HERTZ			 : Hertz;
		CAESIUM_FREQUENCY: Hertz;
		SPEED_OF_LIGHT   : Velocity;
		--PLANK_CONSTANT   : SI_MeasurementSystem;
		--ELEMENTARY_CHARGE: SI_MeasurementSystem; 
		--AVOGRADO		 : SI_MeasurementSystem; 
		MAX_LUMINOUS_FREQ: Hertz;
		LUMINOUS_EFFICACY: SI_MeasurementSystem;
definitions 

------------------------------------------------------------------------------------
--@chapter International Standard Units (and Quantities) 
------------------------------------------------------------------------------------
types

------------------------------------------------------------------------------------
--@section ISQ dimensions
------------------------------------------------------------------------------------

	--@doc SI base units, ordered according to SI's listing; ordered them for pretty printing only
	Dimension = <Length> | <Mass> | <Time> | <Current> | <Temperature> | <Amount> | <Intensity>
	ord d1 < d2 == 
		let 
			value = { <Length> |-> 1, <Mass> |-> 2, <Time> |-> 3,  <Current> |-> 4,  
					  <Temperature> |-> 5,  <Amount> |-> 6,  <Intensity> |-> 7 
					}
		 in value(d1) < value(d2);
	
values
	DIMENSIONS: set1 of Dimension = {<Length>, <Mass>, <Time>, <Current>, <Temperature>, <Amount>, <Intensity>};
	
types
	--@doc SI dimension compositions: two operators, times (counts quantity) and inverse (counts negative quantity)
	--		 total mapping to ensure that we have full dimension information for all base units of interst 
	--		 ex: pressure as kg/ms^2 = { <Mass> |-> 1, <Length> |-> -1, <Time> |-> -2 } (i.e. pascal = kilo per metre per second per second)  
	DimensionVector0= map Dimension to int;
	DimensionlessVector = DimensionVector0
	inv dv == 
		--@doc needs info on all known dimensions
		--@OnFail(4060, "Dimensionless vector missing %1s dimensions = %2s", DIMENSIONS \ dom dv, dv)
		(dom dv = DIMENSIONS)
		and
		--@doc needs at least one dimension set 
		true--rng(dv :-> {0}) <> {} 
		--(dunion rng dv) \ {0} <> {}
		;

	--@doc Invariant insits that there is some dimension in the vector. 
	--     For dimensionless, we get the unit vector (algebraic one), as in DRADIAN or DSTERADIAN
	DimensionVector = DimensionlessVector
	inv dv == 
		--OnFail(4060, "Dimension vector has only dimensionless (0) ranges for %1s", dom(dv :> {0}))
		(rng(dv :-> {0}) <> {});
	
	--@doc The vector where only one of the base unit dimension registers 
	--	   (i.e. only one mapping to 1, and all other mappings are to zero)
	SingleDimension = DimensionVector
	inv sd == card dom (sd :> {1}) = 1 and rng (sd :-> {1}) = {0};
	 
------------------------------------------------------------------------------------
--@section ISQ quantities
------------------------------------------------------------------------------------
  
    --@doc magnitude values 
	Magnitude   = real;
	MagnitudeN0 = Magnitude inv m == m <> 0;
	Magnitude1  = Magnitude	inv m == m > 0;

	--@doc quantity semantic domain as magnitude and a dimension vector to measure it within (e.g. 3 km/hr)
	--@doc the domain is ordered by magnitude when within the same dimension; see quant_lt operators below 
	--@doc some quantities are dimensionless (e.g. radian is meter/meter)
	--		 (i.e. can't compare different dimension quantities directly)
	--@doc quantity equality only compares magnitude.  
	Quantity ::
		mag: Magnitude
		dim:- DimensionlessVector
	--eq  mk_Quantity(m1, d1) = mk_Quantity(m2, d2) == m1 = m2 --and d1 = d2
	ord mk_Quantity(m1, -) < mk_Quantity(m2, -) == m1 < m2 ; --and d1 = d2;
	
	--@doc non-zero quantity in any dimension (e.g. x dimension, x > 0)
	QuantityN0 = Quantity
	inv mk_Quantity(m, -) == is_MagnitudeN0(m);

	--@doc single dimension quantity (e.g. 3km, no 3km/hr)
	SQuantity = Quantity
	inv mk_Quantity(-, d) == is_SingleDimension(d);

	--@doc non-zero single dimension quantity
	SQuantityN0 = SQuantity
	inv sq == is_QuantityN0(sq);
	
	--@doc integer (whole) quanity
	IntQuantity = Quantity
	inv iq == is_int(iq.mag);
		
------------------------------------------------------------------------------------
--@section ISQ measurement systems
------------------------------------------------------------------------------------

	--@doc the name of unit system for measurement; could be enums, but then harder to extend?
	UnitSystem = String1;
	
	--@doc a conversion schema defines (non zero magnitude) factors to convert between 
	--	   measurement systems for all standard dimensions
	ConversionSchema = map Dimension to MagnitudeN0
	inv cs == dom cs = DIMENSIONS;
	
	--@doc Each conversion target associates different conversion schemas to a specific unit system target
	--	   (e.g. converting to BIS with given schema from whatever unit) 
	--@doc Conversions Source to Target unit system conversion schemas.
	Conversion  = map UnitSystem to ConversionSchema;
	
	--@todo conversions matrix could be useful for well known transformations of interest to be instantiated.
	Conversions = map UnitSystem to Conversion
	--@doc It's always possible to convert to itself: crucial to allow bottoming constants up 
	inv cs == forall u in set dom cs & u in set dom cs(u); -- dom cs = dunion { dom i | i in set (rng cs) }
	
	--@doc a measurement system is a conversion schema and a typed quantity, possibly in multiple dimensions
	--@doc equality and comparison can happen between mulitple dimensions within the same measurement system
	--	   (i.e. if conversion schemas are the same for the given unit system)
	MeasurementSystem ::
		quantity: Quantity
		  schema: ConversionSchema
		    unit: UnitSystem
		--@doc quantity dimension vector must agree with conversion schema (e.g. know what to convert to)
	inv mk_MeasurementSystem(mk_Quantity(-, d), s, -) == dom d = dom s
	eq  mk_MeasurementSystem(q1, s1, u1) 
		= 
		mk_MeasurementSystem(q2, s2, u2) 
		==
		q1 = q2 and s1 = s2 and u1 = u2
	ord mk_MeasurementSystem(mk_Quantity(m1, -), -, -) 
		< 
		mk_MeasurementSystem(mk_Quantity(m2, -), -, -) 
		==
		--OnFail(4087, "Cannot compare measurement systems: %1s(%2s) < %3s(%4s)?", u1, m1, u2, m2)
		(m1 < m2)-- and s1 = s2 and u1 = u2)
	;

	MeasurementSystemN0	= MeasurementSystem
	inv ms == is_QuantityN0(ms.quantity);

	--@doc we can prefix either magnitude, quantity or measurement system
	Prefix = (Magnitude | Quantity | MeasurementSystem);

values
	--@doc the dimensionless vector is the one in the vector algebra (i.e. dimensions are added/substracted)
	ZERO_DV   : DimensionlessVector= { i |-> 0 | i in set DIMENSIONS };
	
functions			
------------------------------------------------------------------------------------
--@section ISQ dimension operators
------------------------------------------------------------------------------------

	--@doc composing dimentions is aking to adding them (i.e. exponent laws: metre**i * metre**j = metre**(i+j))
	--		 (e.g. watt = kg * m**2 / s**2, so L=2,M=1,T=-2)
	dim_comp: DimensionlessVector * DimensionlessVector -> DimensionlessVector
	dim_comp(d1, d2) == { d |-> d1(d) + d2(d) | d in set dom d1 inter dom d2 }
	post	
		--@doc if result has dimension, it must have come from either d1 or d2
		--@doc can be dimensionless for case of pure quantities (e.g. radian)
		true--(is_DimensionVector(RESULT) <=> is_DimensionVector(d1) or is_DimensionVector(d2))
		;
		
	--@doc utility for d**2 or d**3 etc (i.e. compose twice/thrice with itself)
	dim_comp_n: DimensionlessVector * nat -> DimensionlessVector
	dim_comp_n(di, n) == 
		fold[DimensionlessVector](dim_comp, ZERO_DV, replicate[DimensionVector](n, di)) 
	post	
		--@doc if result has dimension, it must have come from either d1 or d2
		--@doc can be dimensionless for case of pure quantities (e.g. radian)
		true--(is_DimensionVector(RESULT) <=> is_DimensionVector(di))
	measure
		n;
		
	--@doc inverting dimensions is aking to negating them (i.e. exponent law: metre**-i * 1 / metre**i)
	dim_inv: DimensionlessVector -> DimensionlessVector
	dim_inv(di) == { d |-> -di(d) | d in set dom di }
	post	
		--@doc if result has dimension, it must have come from either d1 or d2
		--@doc can be dimensionless for case of pure quantities (e.g. radian)
		true;--(is_DimensionVector(RESULT) <=> is_DimensionVector(di));
	
	--@doc utility for d**-2 or d**-3 etc (i.e. compose twice/thrice with itself then invert)
	--@todo remove for dim_comp_n negative calling inv?
	dim_inv_n: DimensionlessVector * nat1 -> DimensionlessVector
	dim_inv_n(di, n) == dim_inv(dim_comp_n(di, n))
	post	
		--@doc if result has dimension, it must have come from either d1 or d2
		true;--(is_DimensionVector(RESULT) <=> is_DimensionVector(di));

	--@doc dividing dimensions is aking to composing with the second dimension's inverse 
	dim_div: DimensionlessVector * DimensionlessVector -> DimensionlessVector
	dim_div(d1, d2) == dim_comp(d1, dim_inv(d2))
	post	
		--@doc if result has dimension, it must have come from either d1 or d2
		true;--(is_DimensionVector(RESULT) <=> is_DimensionVector(d1) or is_DimensionVector(d2));
	
types 
	--@doc human readable string for a dimension vector
	DimensionView = map Dimension to String1
	inv dv == dom dv = DIMENSIONS;

values 
	--@doc specific dimension view for each measurement system
	SI_DIM_VIEW: DimensionView = 
		{<Length> |-> "m", <Mass> |-> "kg", <Time> |-> "s", <Current> |-> "A", 
		 <Temperature> |-> "K", <Amount> |-> "mol",  <Intensity> |-> "cd" };

	BIS_DIM_VIEW: DimensionView = SI_DIM_VIEW ++ 
		{<Length> |-> "yard", <Mass> |-> "pound", <Temperature> |-> "rankine" };
			
functions 

	--@doc mapps given dimension on dimension vector to its corresponding dimension view
	print_dim: Dimension * DimensionView * DimensionVector -> String1 
	print_dim(d, dview, dvector) ==
		let exp: nat1 = abs dvector(d) in
			if exp <= 1 then 
				dview(d)
			else 
				"(" ^ dview(d) ^ "**" ^ val2seq_of_char[nat1](exp) ^ ")"  
	pre dvector(d) <> 0;

	--@doc creates a dimension vector print out  
	print_dims: set of Dimension * DimensionView * DimensionVector -> String 
	print_dims(dims, dview, dvector) ==
		if dims = {} then 
			""
		else 
			let d in set dims in
				print_dim(d, dview, dvector) ^ " " ^ print_dims(dims \ {d}, dview, dvector)
	pre 
		--@doc cannot print dimensionless dimension!
		not 0 in set rng (dims <: dvector)
	post 
		--@doc results are non empty except at the end
		(card dims <> 0 => is_String1(RESULT))
	measure
		card dims;

	parenthesise: bool * String -> String
	parenthesise(y, s) == if y then "( " ^ s ^ " )" else s
	post 
		if y then is_String1(RESULT) else RESULT = s;

	--@doc user function to prints a dimention's vector view 
	dim_view: DimensionView * DimensionlessVector -> String1
	dim_view(dview, dvector) == 
		if not is_DimensionVector(dvector) then 
			"1"
		else 
			let 
				pos_dimensions: set of Dimension = { d | d in set dom dvector & dvector(d) > 0 },
				neg_dimensions: set of Dimension = { d | d in set dom dvector & dvector(d) < 0 },
				nominator  : String = print_dims(pos_dimensions, dview, dvector),
				denominator: String = print_dims(neg_dimensions, dview, dvector)  
			in 
				(if pos_dimensions = {} then 
					" 1 " 
			     else 
				 	parenthesise(neg_dimensions <> {} and card pos_dimensions > 1, nominator) 
				)
				^ 
				(if neg_dimensions <> {} then 
					" / " ^ parenthesise(card neg_dimensions > 1, denominator) 
				 else 
				    ""
				);

	--@doc dimension view for any SI prefix
	si_dim_view: Prefix -> String1 
	si_dim_view(x) == 
		cases true:
			(is_Magnitude(x))         -> val2seq_of_char[Magnitude](x),
			(is_Quantity(x))          -> dim_view(SI_DIM_VIEW, x.dim),
			(is_MeasurementSystem(x)) -> dim_view(SI_DIM_VIEW, x.quantity.dim)
		end;

	--@doc dimension view for any BIS prefix
	bis_dim_view: Prefix -> String1 
	bis_dim_view(x) == 
		cases true:
			(is_Magnitude(x))         -> val2seq_of_char[Magnitude](x),
			(is_Quantity(x))          -> dim_view(BIS_DIM_VIEW, x.dim),
			(is_MeasurementSystem(x)) -> dim_view(BIS_DIM_VIEW, x.quantity.dim)
		end;

------------------------------------------------------------------------------------
--@section ISQ quantity operators
------------------------------------------------------------------------------------
	
	--@doc check whether two dimensions have the same quantity dimension vector
	quant_dim_eq: Quantity * Quantity -> bool
	quant_dim_eq(mk_Quantity(-, d1), mk_Quantity(-, d2)) == d1 = d2; 
		
	--@doc multiplying quantities multiply their magnitude and compose their dimensions
	quant_times: Quantity * Quantity -> Quantity
	quant_times(mk_Quantity(m1, d1), mk_Quantity(m2, d2)) == 
		mk_Quantity(m1*m2, dim_comp(d1, d2));
		
	--@doc given m, 3 you get m**3
	quant_itself_n: Quantity * nat1 -> Quantity
	quant_itself_n(mk_Quantity(m, d), n) == mk_Quantity(m, dim_comp_n(d, n));
		 
	--@doc dividing quantities divides their magnitude and divides their dimensions
	--@doc notice the second argument must be a non-zero quantity
	quant_div: Quantity * QuantityN0 -> Quantity
	quant_div(mk_Quantity(m1, d1), mk_Quantity(m2, d2)) ==
		mk_Quantity(m1/m2, dim_div(d1, d2));
		
	--@doc given q, you get 1/q 
	--@doc inverting quantities invert their magnitude and invert their dimensions
	quant_inv: QuantityN0 -> Quantity
	quant_inv(q) == quant_div(mk_Quantity(1, q.dim), q);

	--@doc given q, you get 1/q**n 
	quant_inv_n: QuantityN0 * nat1 -> Quantity
	quant_inv_n(q, n) == quant_inv(quant_itself_n(q, n));
		
	--@doc summing quantities sum their magnitude, providing they have the same dimension
	--@doc if it's for a single dimension quantity input, you get a single dimension quantity output 
	quant_plus: Quantity * Quantity -> Quantity
	quant_plus(d1, d2) == mk_Quantity(d1.mag + d2.mag, d1.dim)
	pre
		quant_dim_eq(d1, d2)
	post
		(is_SQuantity(d1) <=> is_SQuantity(RESULT));
		
	--@doc summing quantities sum their magnitude, providing they have the same dimension
	quant_uminus: Quantity -> Quantity
	quant_uminus(d1) == mk_Quantity(-d1.mag, d1.dim)
	post
		(is_SQuantity(d1) <=> is_SQuantity(RESULT));

	--@doc summing quantities sum their magnitude, providing they have the same dimension
	quant_minus: Quantity * Quantity -> Quantity
	quant_minus(d1, d2) == mk_Quantity(d1.mag - d2.mag, d1.dim)
	pre
		quant_dim_eq(d1, d2)
	post
		(is_SQuantity(d1) <=> is_SQuantity(RESULT));

	--@doc scale a quantity magnitude by given magnitude 
	scaleQ: Magnitude * Quantity -> Quantity
	scaleQ(m1, mk_Quantity(m2, d)) == mk_Quantity(m1 * m2, d);

------------------------------------------------------------------------------------
--@section ISQ basic dimension vectors and common units
------------------------------------------------------------------------------------

values
	--@doc basic dimension vectors
	DLENGTH   : SingleDimension = ZERO_DV ++ { <Length>      |-> 1 }; -- L
	DMASS     : SingleDimension = ZERO_DV ++ { <Mass>        |-> 1 }; -- M
	DTIME     : SingleDimension = ZERO_DV ++ { <Time>        |-> 1 }; -- T
	DCURRENT  : SingleDimension = ZERO_DV ++ { <Current>     |-> 1 }; -- I (be careful this is not intensity, but charge)!
	DTEMP     : SingleDimension = ZERO_DV ++ { <Temperature> |-> 1 }; -- theta
	DAMOUNT   : SingleDimension = ZERO_DV ++ { <Amount>      |-> 1 }; -- N
	DINTENSITY: SingleDimension = ZERO_DV ++ { <Intensity>   |-> 1 }; -- J

	--@doc common dimension units
	DAREA        : DimensionVector = dim_comp_n(DLENGTH, 2);                                  --L**2
	DVOLUME      : DimensionVector = dim_comp_n(DLENGTH, 3);                                  --L**3
	DFREQUENCY   : DimensionVector = dim_inv(DTIME);                                          --T**-1
	DVELOCITY    : DimensionVector = dim_comp(DLENGTH, DFREQUENCY);                           --L*T**-1
	DACCELERATION: DimensionVector = dim_comp(DVELOCITY, DFREQUENCY);                         --L*T**-2
	DENERGY      : DimensionVector = dim_comp(DAREA, dim_comp(DMASS, dim_inv_n(DTIME, 2)));   --L**2*M*T**-2
	DPOWER       : DimensionVector = dim_comp(DAREA, dim_comp(DMASS, dim_inv_n(DTIME, 3)));   --L**2*M*T**-3
	DFORCE       : DimensionVector = dim_comp(DLENGTH, dim_comp(DMASS, dim_inv_n(DTIME, 2))); --L*M*T**-2
	DPRESSURE    : DimensionVector = dim_comp(dim_inv(DLENGTH), dim_comp(DMASS, dim_inv_n(DTIME, 2)));  --L**-1*M*T**-2               
	DCHARGE      : DimensionVector = dim_comp(DCURRENT, DTIME);                            --I*T
	DPDIFFERENCE : DimensionVector = dim_comp(DAREA, dim_comp(DMASS, dim_comp(dim_inv_n(DTIME, 3), dim_inv(DCURRENT)))); --L**2*M*T**-3*I**-1
	DCAPACITANCE : DimensionVector = dim_comp(dim_inv(DAREA),                               --L**-2*M**-1*T**4*I**2
											dim_comp(dim_inv(DMASS), 
												dim_comp(dim_comp_n(DTIME, 4), 
																	dim_comp_n(DCURRENT, 2))));
	DRADIAN      : DimensionlessVector = dim_comp(DLENGTH, dim_inv(DLENGTH));                    --L*L**-1
	DSTERADIAN   : DimensionlessVector = dim_comp(DAREA, dim_inv(DAREA));                        --L**2*L**-2
	DWATT        : DimensionVector     = dim_comp(DAREA, dim_comp(DMASS, dim_inv_n(DTIME, 3)));  --L**2*M*T**-3
	
  	--@doc identity conversion schema maps all dimensions to 1 (i.e. no conversion)
  	CONV_ID     : ConversionSchema = { i |-> 1 | i in set DIMENSIONS };
  
------------------------------------------------------------------------------------
--@section International Standard Units constants basic, accepted, derived, prefixes 
------------------------------------------------------------------------------------

	--@doc single unit of quantity for each base dimension  
	UNIT_LENGTH   : IntQuantity   = mk_Quantity(1, DLENGTH);
	UNIT_MASS     : IntQuantity   = mk_Quantity(1, DMASS);
	UNIT_TIME     : IntQuantity   = mk_Quantity(1, DTIME);
	UNIT_CURRENT  : IntQuantity   = mk_Quantity(1, DCURRENT);
	UNIT_TEMP     : IntQuantity   = mk_Quantity(1, DTEMP);
	UNIT_AMOUNT   : IntQuantity   = mk_Quantity(1, DAMOUNT);
	UNIT_INTENSITY: IntQuantity   = mk_Quantity(1, DINTENSITY);

	--@doc common SI prefixes
	PREFIX_DECA   : MagnitudeN0 = (10**1);
	PREFIX_HECTO  : MagnitudeN0 = (10**2)  ;
	PREFIX_KILO   : MagnitudeN0 = (10**3)  ;
	PREFIX_MEGA   : MagnitudeN0 = (10**4)  ;
	PREFIX_GIGA   : MagnitudeN0 = (10**5)  ;
	PREFIX_TERA   : MagnitudeN0 = (10**6);
	PREFIX_DECI   : MagnitudeN0 = 1/PREFIX_DECA;
	PREFIX_CENTI  : MagnitudeN0 = 1/PREFIX_HECTO;
	PREFIX_MILLI  : MagnitudeN0 = 1/PREFIX_KILO;
	PREFIX_MICRO  : MagnitudeN0 = 1/PREFIX_MEGA;
	PREFIX_NANO   : MagnitudeN0 = 1/PREFIX_GIGA;
	PREFIX_PICO   : MagnitudeN0 = 1/PREFIX_TERA;

	--@doc single unit of quantity for each base dimension  
	UNIT_AREA        : IntQuantity = mk_Quantity(1, DAREA)         ;
	UNIT_VOLUME      : IntQuantity = mk_Quantity(1, DVOLUME)       ;
	UNIT_FREQUENCY   : IntQuantity = mk_Quantity(1, DFREQUENCY)    ;
	UNIT_VELOCITY    : IntQuantity = mk_Quantity(1, DVELOCITY)     ;
	UNIT_ACCELERATION: IntQuantity = mk_Quantity(1, DACCELERATION) ;
	UNIT_ENERGY      : IntQuantity = mk_Quantity(1, DENERGY)       ;
	UNIT_POWER       : IntQuantity = mk_Quantity(1, DPOWER)        ;
	UNIT_FORCE       : IntQuantity = mk_Quantity(1, DFORCE)        ;
	UNIT_PRESSURE    : IntQuantity = mk_Quantity(1, DPRESSURE)     ;
	UNIT_CHARGE      : IntQuantity = mk_Quantity(1, DCHARGE)       ;
	UNIT_PDIFFERENCE : IntQuantity = mk_Quantity(1, DPDIFFERENCE);
	UNIT_CAPACITANCE : IntQuantity = mk_Quantity(1, DCAPACITANCE) ;

	UNIT_RADIAN      : IntQuantity = mk_Quantity(1, DRADIAN)       ;
	UNIT_STERADIAN   : IntQuantity = mk_Quantity(1, DSTERADIAN)    ;
	UNIT_WATT        : IntQuantity = mk_Quantity(1, DWATT)         ;
	
------------------------------------------------------------------------------------
--@section SI basic and derived unit types
------------------------------------------------------------------------------------
	SI_UNIT: UnitSystem = "SI";
	
	--@doc International Systems of Units "Systeme Internacional" base units and conversion schemas
	SI: ConversionSchema = CONV_ID;

	HOURS_PER_DAY: nat1 = 24;
	DAYS_PER_WEEK: nat1 =  7;

types
	--@doc an SI measurement system has an SI conversion
	SI_MeasurementSystem = MeasurementSystem
	inv mk_MeasurementSystem(-, s, u) == s = SI and u = SI_UNIT;
	
	--@doc every standard basic dimension has an SI measurement system type
	Meter = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DLENGTH;

	Kilogram = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DMASS;

	--@doc second is common between different conversion schemas, so only fix the dimension, not conversion schema
	Second = MeasurementSystem
	inv ms == ms.quantity.dim = DTIME;
	
	Ampere = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DCURRENT;
	
	Kelvin = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DTEMP;
	
	Mole = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DAMOUNT;
	
	Candela = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DINTENSITY;

	--@doc common derived SI measurement systems
	Area = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DAREA;
	
	Volume = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DVOLUME;

	Frequency = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DFREQUENCY;

	Velocity = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DVELOCITY;

	Acceleration = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DACCELERATION;

	Energy = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DENERGY;

	Power = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DPOWER;

	Force = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DFORCE;

	Pressure = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DPRESSURE;

	Charge = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DCHARGE;

	PotentialDifference = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DPDIFFERENCE;
    
	Capacitance = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DCAPACITANCE;	

	--@doc some commonly derived SI measurement system dimensions types
	Hertz = Frequency;
	
	Radian = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DRADIAN; 
	
	Steradian = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DSTERADIAN;
	
	Watt = SI_MeasurementSystem
	inv ms == ms.quantity.dim = DWATT;

functions	
------------------------------------------------------------------------------------
--@section ISQ scaling and conversion over quantities and measurement systems
------------------------------------------------------------------------------------

	--@doc scale a dimension by given magnitude within a measurement system
	scaleMS: Magnitude * MeasurementSystem -> MeasurementSystem
	scaleMS(m1, mk_MeasurementSystem(q, s, u)) == mk_MeasurementSystem(scaleQ(m1, q), s, u);
	
	--@doc to quantity convert in multiple dimensions, we must use product of the integer exponenciation on the dimensions
	--     for all dimensions. Those with zero dimension, will lead to 1, others will be multiplied accordingly
	quant_conv: ConversionSchema * DimensionlessVector -> MagnitudeN0
	quant_conv(cs, dv) ==
		prods_r({ cs(i)**dv(i) | i in set dom cs inter dom dv })
	pre
		dom cs = dom dv;

------------------------------------------------------------------------------------
--@section ISQ measurement systems operators
------------------------------------------------------------------------------------
	
	--@doc check whether two measurement systems have the same unit system
	ms_conv_eq: MeasurementSystem * MeasurementSystem -> bool
	ms_conv_eq(m1, m2) == m1.schema = m2.schema and m1.unit = m2.unit;
		
	--@doc multiplying measurement system quantities providing we keep their unit system
	ms_times: MeasurementSystem * MeasurementSystem -> MeasurementSystem
	ms_times(m1, m2) == 
		mk_MeasurementSystem(quant_times(m1.quantity, m2.quantity), m1.schema, m1.unit)
	pre
		ms_conv_eq(m1, m2);
	
	ms_itself_n: MeasurementSystem * nat1 -> MeasurementSystem
	ms_itself_n(mk_MeasurementSystem(q, s, u), n) == 
		mk_MeasurementSystem(quant_itself_n(q, n), s, u);  

	--@doc inverting measurement system quantities providing we keep their conversion scehma
	ms_inv: MeasurementSystemN0 -> MeasurementSystem
	ms_inv(mk_MeasurementSystem(q, s, u)) == mk_MeasurementSystem(quant_inv(q), s, u);
		
	ms_inv_n: MeasurementSystemN0 * nat1 -> MeasurementSystem
	ms_inv_n(m, n) == ms_inv(ms_itself_n(m, n));
		
	--@doc dividing quantities divides their magnitude and divides their dimensions
	--@doc notice the second argument must be a non-zero quantity
	ms_div: MeasurementSystem * MeasurementSystemN0 -> MeasurementSystem
	ms_div(m1, m2) == mk_MeasurementSystem(quant_div(m1.quantity, m2.quantity), m1.schema, m1.unit)
	pre 
		ms_conv_eq(m1, m2);
			
------------------------------------------------------------------------------------
--@section ISQ conversion operators
------------------------------------------------------------------------------------
	
	--@doc inverse of conversion 	
	conv_inv: ConversionSchema -> ConversionSchema
	conv_inv(cs) == { i |-> 1/cs(i) | i in set dom cs }
	post
		dom cs = dom RESULT;
	
	--@doc composition (times) conversion
	conv_comp: ConversionSchema * ConversionSchema -> ConversionSchema
	conv_comp(cs1, cs2) == { i |-> cs1(i)*cs2(i) | i in set dom cs1 inter dom cs2 }
	pre
		dom cs1 = dom cs2
	post
		dom cs1 = dom RESULT;

	--@doc given a conversion schema (cs_conv) and a measurement system, convert the quantity by 
	--     converting the magnitude according to the schema (cs_conv), keeping the given schema (cs)
	--     (i.e. it is will be transformed by ms_conv)
	ms_quant_conv: ConversionSchema * MeasurementSystem -> MeasurementSystem
	ms_quant_conv(cs_conv, mk_MeasurementSystem(mk_Quantity(m, d), s, u)) ==
		--@todo this ought to be cs_conv unit for s?!
		mk_MeasurementSystem(mk_Quantity(quant_conv(cs_conv, d) * m, d), s, u);
		
	--@doc From -> To convert(ms): 
	--     given a measurement system (ms), convert its quantity from the given conversion schema 
	--     to the selected conversion schema (i.e. inverting and composing schemas, then
	--     converting the magnitude accordingly). Avoid id conversion for speed.
	ms_conv: /*ConversionSchema * ConversionSchema * MeasurementSystem*/ MeasurementSystem * ConversionSchema -> MeasurementSystem
	ms_conv(/*cs_from, cs_to, ms*/ms, cs_to) == 
		let
			cs_from : ConversionSchema = ms.schema
		 in
			if cs_from = cs_to then 
				ms
			else
				ms_quant_conv(conv_comp(cs_from, conv_inv(cs_to)), ms)
	/*
	--@todo this is to take Conversions into account, which isn't there yet? 
	pre
		cs_from = ms.schema
	post
		conv_comp(cs_from, conv_inv(cs_to)) = RESULT.schema;
	*/	
	;

------------------------------------------------------------------------------------
--@section SI prefixes
------------------------------------------------------------------------------------
	
	--@doc project the magnitude of a quantity or measurement system
	mag: Prefix -> Magnitude
	mag(x) == 
		cases true:
			(is_Magnitude(x))         -> x,
			(is_Quantity(x))          -> x.mag,
			(is_MeasurementSystem(x)) -> x.quantity.mag
		end;

	--@doc multiply magnitude, quantity or measurement system
	scale_prefix: Prefix * Magnitude -> Prefix
	scale_prefix(x, p) == 
		cases true:
			(is_Magnitude(x))         -> x * p,
			(is_Quantity(x))          -> scaleQ(p, x),
			(is_MeasurementSystem(x)) -> scaleMS(p, x)
		end;

	deca: Prefix -> Prefix
	deca(x) == scale_prefix(x, PREFIX_DECA );

	hecto: Prefix -> Prefix
	hecto(x)== scale_prefix(x, PREFIX_HECTO);

	kilo: Prefix -> Prefix
	kilo(x) == scale_prefix(x, PREFIX_KILO );

	mega: Prefix -> Prefix
	mega(x) == scale_prefix(x, PREFIX_MEGA );

	giga: Prefix -> Prefix
	giga(x) == scale_prefix(x, PREFIX_GIGA );

	tera: Prefix -> Prefix
	tera(x) == scale_prefix(x, PREFIX_TERA );
	
	deci: Prefix -> Prefix
	deci(x) == scale_prefix(x, PREFIX_DECI );

	centi: Prefix -> Prefix
	centi(x)== scale_prefix(x, PREFIX_CENTI);

	milli: Prefix -> Prefix
	milli(x)== scale_prefix(x, PREFIX_MILLI);

	micro: Prefix -> Prefix
	micro(x)== scale_prefix(x, PREFIX_MICRO);

	nano: Prefix -> Prefix
	nano(x) == scale_prefix(x, PREFIX_NANO );

	pico: Prefix -> Prefix
	pico(x) == scale_prefix(x, PREFIX_PICO );	
	
------------------------------------------------------------------------------------
--@section SI common time measurements, which are the same across SI and BIS etc.
------------------------------------------------------------------------------------

	second: ConversionSchema * UnitSystem -> Second
	second(cs, u) == mk_MeasurementSystem(UNIT_TIME, cs, u);
	
	--@doc we take hour as the "base" unit of time, instead of SI's second given our use (i.e. smaller numbers?);
	--		 this can be easily generalised to seconds or whatver needed 
	minute: ConversionSchema * UnitSystem -> Second
	minute(cs, u) == scaleMS(60, second(cs, u));
	
	hour: ConversionSchema * UnitSystem -> Second 
	hour(cs, u) == scaleMS(60, minute(cs, u));
	
	day: ConversionSchema * UnitSystem -> Second 
	day(cs, u) == scaleMS(24, hour(cs, u));
	
	week: ConversionSchema * UnitSystem -> Second
	week(cs, u) == scaleMS(DAYS_PER_WEEK, day(cs, u));
		
-----------------------------------------------------------------------------------
--@section SI accepted constants and known dimensions
------------------------------------------------------------------------------------
values
	METER   : Meter    = mk_MeasurementSystem(UNIT_LENGTH   , SI, SI_UNIT);
	KILOGRAM: Kilogram = mk_MeasurementSystem(UNIT_MASS     , SI, SI_UNIT);
	SECOND	: Second   = mk_MeasurementSystem(UNIT_TIME     , SI, SI_UNIT); 
	AMPERE  : Ampere   = mk_MeasurementSystem(UNIT_CURRENT  , SI, SI_UNIT); 
	KELVIN  : Kelvin   = mk_MeasurementSystem(UNIT_TEMP     , SI, SI_UNIT); 
	MOLE    : Mole     = mk_MeasurementSystem(UNIT_AMOUNT   , SI, SI_UNIT); 
	CANDELA : Candela  = mk_MeasurementSystem(UNIT_INTENSITY, SI, SI_UNIT); 
	
	SI_AREA        : Area         = mk_MeasurementSystem(UNIT_AREA              , SI, SI_UNIT);
	SI_VOLUME      : Volume       = mk_MeasurementSystem(UNIT_VOLUME            , SI, SI_UNIT);
	SI_FREQUENCY   : Frequency    = mk_MeasurementSystem(UNIT_FREQUENCY         , SI, SI_UNIT);
	SI_VELOCITY    : Velocity     = mk_MeasurementSystem(UNIT_VELOCITY          , SI, SI_UNIT);
	SI_ACCELERATION: Acceleration = mk_MeasurementSystem(UNIT_ACCELERATION      , SI, SI_UNIT);
	SI_ENERGY      : Energy       = mk_MeasurementSystem(UNIT_ENERGY            , SI, SI_UNIT);
	SI_POWER       : Power        = mk_MeasurementSystem(UNIT_POWER             , SI, SI_UNIT);
	SI_FORCE       : Force        = mk_MeasurementSystem(UNIT_FORCE             , SI, SI_UNIT);
	SI_PRESSURE    : Pressure     = mk_MeasurementSystem(UNIT_PRESSURE          , SI, SI_UNIT);
	SI_CHARGE      : Charge       = mk_MeasurementSystem(UNIT_CHARGE            , SI, SI_UNIT);
	SI_PDIFFERENCE : PotentialDifference = mk_MeasurementSystem(UNIT_PDIFFERENCE, SI, SI_UNIT);
	SI_CAPACITANCE : Capacitance  = mk_MeasurementSystem(UNIT_CAPACITANCE       , SI, SI_UNIT);
                                                                              
	SI_RADIAN	   : Radian	      = mk_MeasurementSystem(UNIT_RADIAN            , SI, SI_UNIT);
	SI_STERADIAN   : Steradian    = mk_MeasurementSystem(UNIT_STERADIAN         , SI, SI_UNIT);
	SI_WATT		   : Watt	      = mk_MeasurementSystem(UNIT_WATT              , SI, SI_UNIT);

functions
	
	--@doc transform given measurement system to the International Standard system	   	
	metrify: MeasurementSystem -> Quantity
	metrify(ms) == ms_conv(ms, SI).quantity;
	
	SI_ASTRONOMICAL: () -> Meter
	SI_ASTRONOMICAL() == scaleMS(149597870700, METER);

	SI_DEGREE: () -> Radian
	SI_DEGREE() == scaleMS(2*pi_f()/180, SI_RADIAN);--scaleMS(2*3.14159265358979323846/180, SI_RADIAN);
	
	SI_LITRE: () -> Volume
	SI_LITRE() == scaleMS(mag(milli(1)), SI_VOLUME);
	
	SI_TONNE: () -> Kilogram
	SI_TONNE() == scaleMS(mag(kilo(1)), KILOGRAM);

------------------------------------------------------------------------------------
--@section SI common imperial conversions
------------------------------------------------------------------------------------

	SI_YARD: () -> Meter
	SI_YARD() == scaleMS(0.9144, METER);
	
	SI_FOOT: () -> Meter
	SI_FOOT() == scaleMS(1/3, SI_YARD());
	
	SI_INCH: () -> Meter
	SI_INCH() == scaleMS(1/36, SI_YARD());
	
	SI_MILE: () -> Meter
	SI_MILE() == scaleMS(1760, SI_YARD());
	
	SI_NAUTICAL_MILE: () -> Meter
	SI_NAUTICAL_MILE() == scaleMS(1852, METER);
	
	SI_POUND: () -> Kilogram
	SI_POUND() == scaleMS(0.45359237, KILOGRAM);
	
	SI_OUNCE: () -> Kilogram
	SI_OUNCE() == scaleMS(1/16, SI_POUND());
	
	SI_STONE: () -> Kilogram
	SI_STONE() == scaleMS(14, SI_POUND());
	
	SI_KNOT: () -> Velocity
	SI_KNOT() == ms_div(SI_NAUTICAL_MILE(), hour(SI, SI_UNIT));
	
	SI_MPH: () -> Velocity
	SI_MPH() == ms_div(SI_MILE(), hour(SI, SI_UNIT));
	
	--@doc the standard velocity in SI is meters per second 
	SI_MPS: () -> Velocity
	SI_MPS() == SI_VELOCITY;

	SI_KPH: () -> Velocity
	SI_KPH() == ms_div(kilo(METER), hour(SI, SI_UNIT));
	
	SI_PINT: () -> Volume
	SI_PINT() == scaleMS(0.56826125, SI_LITRE());
	
	SI_GALLON: () -> Volume
	SI_GALLON() == scaleMS(8, SI_PINT());
	
	SI_DEGREES_FARENHEIT: Magnitude -> Kelvin
	SI_DEGREES_FARENHEIT(x) == scaleMS((x + 459.67) * 5/9, KELVIN);

	SI_JOULE: () -> SI_MeasurementSystem
	SI_JOULE() == ms_times(KILOGRAM, ms_times(/*SI_AREA()*/ms_itself_n(METER, 2), ms_inv_n(second(SI, SI_UNIT), 2)));

	SI_COLOUMB: () -> SI_MeasurementSystem 
	SI_COLOUMB() == ms_times(AMPERE, SECOND);

	SI_LUMEN: () -> SI_MeasurementSystem
	SI_LUMEN() == ms_times(CANDELA, ms_times(ms_itself_n(METER, 2), ms_inv_n(METER, 2)));
					 
------------------------------------------------------------------------------------
--@section British Imperial measurement system setup and common conversions
------------------------------------------------------------------------------------
values
	BIS_UNIT   : UnitSystem = "BIS";
	--@doc British Imperial System; choose Rankine instead of Farenheit for offset simplicity
	BIS: ConversionSchema = CONV_ID ++ 
		{ <Length> |-> 0.9143993, <Mass> |-> 0.453592338, <Temperature> |-> 5/9 };

types
	--@doc an BIS measurement system has an BIS conversion
	BIS_MeasurementSystem = MeasurementSystem
	inv ms == ms.schema = BIS and ms.unit = BIS_UNIT;
	
	Yard = BIS_MeasurementSystem
	inv ms == ms.quantity.dim = DLENGTH;
	
	Pound = BIS_MeasurementSystem
	inv ms == ms.quantity.dim = DMASS;
	
	Rankine = BIS_MeasurementSystem
	inv ms == ms.quantity.dim = DTEMP;
	
	BISVolume = BIS_MeasurementSystem
	inv ms == ms.quantity.dim = DVOLUME;
	
	BISVelocity = BIS_MeasurementSystem
	inv ms == ms.quantity.dim = DVELOCITY;
	
values
	BIS_YARD    : Yard       = mk_MeasurementSystem(UNIT_LENGTH  , BIS, BIS_UNIT);
	BIS_POUND   : Pound      = mk_MeasurementSystem(UNIT_MASS    , BIS, BIS_UNIT);
	BIS_RANKINE : Rankine    = mk_MeasurementSystem(UNIT_TEMP    , BIS, BIS_UNIT);
	BIS_VOLUME  : BISVolume  = mk_MeasurementSystem(UNIT_VOLUME  , BIS, BIS_UNIT);
    BIS_VELOCITY: BISVelocity= mk_MeasurementSystem(UNIT_VELOCITY, BIS, BIS_UNIT);
functions
	
	--@doc transform given measurement system to the British Imperial System
	imperialise: MeasurementSystem -> Quantity
	imperialise(ms) == ms_conv(ms, BIS).quantity;

	BIS_FOOT: () -> Yard
	BIS_FOOT() == scaleMS(1/3, BIS_YARD);

	BIS_INCH: () -> Yard
	BIS_INCH() == scaleMS(1/12, BIS_FOOT());
	
	BIS_MILE: () -> Yard
	BIS_MILE() == scaleMS(1760, BIS_YARD);
	
	BIS_ACRE: () -> BISVolume
	BIS_ACRE() == scaleMS(4840, BIS_VOLUME);

	BIS_OUNCE: () -> Pound
	BIS_OUNCE() == scaleMS(1/12, BIS_POUND);
	
	--@todo inch**3 x yard**3?
	BIS_GALLON: () -> BISVolume
	BIS_GALLON() == 	
		let inch			: Yard 		  = BIS_INCH(),
			inch_cubed: BISVolume = ms_times(inch, ms_times(inch, inch))
		 in
		    scaleMS(277.421, inch_cubed);
		  
	BIS_PINT: () -> BISVolume
	BIS_PINT() == scaleMS(1/8, BIS_GALLON());
	
	BIS_MILE_PER_HOUR: () -> BISVelocity
	BIS_MILE_PER_HOUR() == ms_div(BIS_MILE(), hour(BIS, BIS_UNIT));
	
------------------------------------------------------------------------------------
--@section Other measurement system of interest setup
------------------------------------------------------------------------------------
values 
	CGS_UNIT: UnitSystem = "CGS";
	MHC_UNIT: UnitSystem = "MHC";
	
	--@doc Centemetre-Gram-Second system;	
	CGS: ConversionSchema = CONV_ID ++ { <Length> |-> mag(centi(METER)), <Mass> |-> mag(milli(KILOGRAM)) };

	--@doc Miligram-Hour system;
	MHC: ConversionSchema = CONV_ID ++ { <Mass> |-> mag(milli(milli(KILOGRAM))), <Time> |-> mag(hour(SI, SI_UNIT)), <Temperature> |-> -272.15 };

	WEEKS_PER_YEAR : nat1 = 52;
	MONTHS_PER_YEAR: nat1 = 12;
	DAYS_PER_YEAR  : nat1 = 365;

types
	CGS_MeasurementSystem = MeasurementSystem
	inv ms == ms.schema = CGS and ms.unit = CGS_UNIT;
	
	Centimetre = CGS_MeasurementSystem
	inv ms == ms.quantity.dim = DLENGTH;
	
	Gram = CGS_MeasurementSystem
	inv ms == ms.quantity.dim = DMASS;
	
	
	MHC_MeasurementSystem = MeasurementSystem
	inv ms == ms.schema = MHC and ms.unit = MHC_UNIT;
	
	Milligram = MHC_MeasurementSystem
	inv ms == ms.quantity.dim = DMASS;
	
	Hour = MHC_MeasurementSystem
	inv ms == ms.quantity.dim = DTIME;
	
	Celcius = MHC_MeasurementSystem
	inv ms == ms.quantity.dim = DTEMP;
		
	WhichMonth = nat1
	inv wm == wm <= MONTHS_PER_YEAR;
	
	HowManyDays = nat1
	inv hmd == hmd in set {28,...,31};
	
values 
	CENTIMETRE: Centimetre = mk_MeasurementSystem(UNIT_LENGTH, CGS, CGS_UNIT);
	GRAM      : Gram			 = mk_MeasurementSystem(UNIT_MASS  , CGS, CGS_UNIT);

	MGRAM		: Milligram = mk_MeasurementSystem(UNIT_MASS, MHC, MHC_UNIT); --1mg=(1kg/1000)/1000
	MHOUR   : Hour 			= mk_MeasurementSystem(UNIT_TIME, MHC, MHC_UNIT);--hour(MHC); --1hr
	MCELCIUS: Celcius 	= mk_MeasurementSystem(UNIT_TEMP, MHC, MHC_UNIT); --1c = -272.15k
	--MMHG  : IntQuantity   = UNIT_????; in KILOGRAM / (METER * SECOND**2)

	DAYS_PER_MONTH : map WhichMonth to HowManyDays = {1|->31, 2|->28, 3|->31, 4|->30, 5|->31, 6|->30,
                                 			            7|->31, 8|->31, 9|->30, 10|->31, 11|->30, 12|->31};

functions
	
	hDAY: () -> Hour
	hDAY() == scaleMS(HOURS_PER_DAY, MHOUR);
	
	hWEEK : () -> Hour 
	hWEEK() == scaleMS(DAYS_PER_WEEK, hDAY());
	
	hMONTH: WhichMonth -> Hour 
	hMONTH(m) == scaleMS(DAYS_PER_MONTH(m), hDAY());
	
	hAVG_MONTH: () -> Hour
	hAVG_MONTH() == scaleMS(averages_r(rng DAYS_PER_MONTH), hDAY());
	
	hYEAR : () -> Hour
	hYEAR() == scaleMS(DAYS_PER_YEAR, hDAY());
	
	hW2M: () -> Hour
	hW2M() == ms_times(hWEEK(), ms_inv(hAVG_MONTH()));
	
	weeks2months_hrs: nat1 -> Hour
	weeks2months_hrs(w) == scaleMS(w, hW2M());
	
	--@doc 3 times a day = DAY() / 3 = 1 times 8 hours;
	--		 DAY()= 24hrs / 3 =  8hrs
	--@doc don't change the dimension vector, so just scale by the inverse
	n_times_day2every_x_hours: nat1 -> real
	n_times_day2every_x_hours(times_a_day) == mag(scaleMS(1/mag(scaleMS(times_a_day, MHOUR)), hDAY()));

values
	MDC_UNIT: UnitSystem = "MDC";
	MDC: ConversionSchema = MHC ++ { <Time> |-> mag(metrify(hDAY())) };
	
	MWC_UNIT: UnitSystem = "MWC";
	MWC: ConversionSchema = MHC ++ { <Time> |-> mag(metrify(hWEEK())) };
	 
types
	MDC_MeasurementSystem = MeasurementSystem
	inv ms == ms.schema = MDC and ms.unit = MDC_UNIT;
	
	Day = MDC_MeasurementSystem
	inv ms == ms.quantity.dim = DTIME;
	
	MWC_MeasurementSystem = MeasurementSystem
	inv ms == ms.schema = MWC and ms.unit = MWC_UNIT;
	
	Week = MWC_MeasurementSystem
	inv ms == ms.quantity.dim = DTIME;

values
	MDAY : Day  = mk_MeasurementSystem(UNIT_TIME, MDC, MDC_UNIT);
	MWEEK: Week = mk_MeasurementSystem(UNIT_TIME, MWC, MWC_UNIT);
		
functions
	
	dWEEK: () -> Day
	dWEEK() == scaleMS(DAYS_PER_WEEK, MDAY);
	
	weeks2days: nat1 -> Day
	weeks2days(n) == scaleMS(n, dWEEK());

	wDAY: () -> Week
	wDAY() == scaleMS(1/DAYS_PER_WEEK, MWEEK);
	
	wAVG_MONTH: () -> Week
	wAVG_MONTH() == scaleMS(averages_r(rng DAYS_PER_MONTH), wDAY());
	
	wW2M: () -> Week
	wW2M() == ms_times(MWEEK, ms_inv(wAVG_MONTH()));
	
	weeks2months_wks: nat1 -> Week
	weeks2months_wks(w) == scaleMS(w, wW2M());

------------------------------------------------------------------------------------
--@section SI constants
------------------------------------------------------------------------------------	 

values
	HERTZ			 : Hertz = SI_FREQUENCY;
	CAESIUM_FREQUENCY: Hertz = scaleMS(9192631770, HERTZ);
	SPEED_OF_LIGHT   : Velocity = scaleMS(299792458, SI_VELOCITY);
	--@LF this requires HighPrecision to work
	--PLANK_CONSTANT   : SI_MeasurementSystem = scaleMS(6.62607015 * (1/(10**34)), ms_times(SI_JOULE(), SECOND));
	--ELEMENTARY_CHARGE: SI_MeasurementSystem = scaleMS(1.602176634 * (1/(10**19)), SI_COLOUMB());
	--AVOGRADO		 : SI_MeasurementSystem = scaleMS(6.02214076 * (10**23), ms_inv(MOLE));
	MAX_LUMINOUS_FREQ: Hertz = scaleMS(540 * (10**12), HERTZ);
	LUMINOUS_EFFICACY: SI_MeasurementSystem = scaleMS(683, ms_div(SI_LUMEN(), SI_WATT));

------------------------------------------------------------------------------------
--@section Useful for testing in approximating
------------------------------------------------------------------------------------	 
values
	ORDER_MAGNITUDE: nat = 10;
	
functions
	
	--@doc approximate to the given precision; useful for comparing up to an order of magnitude
	approx: Magnitude * nat -> Magnitude
	approx(m, precision) == m * (10**precision);
	
	--@doc approximate  both sides to the same precision then floor them for equality testing
	approx_eq: Magnitude * Magnitude * nat -> bool
	approx_eq(lhs, rhs, precision) == 
		let 
			lhs': Magnitude = approx(lhs, precision),
			rhs': Magnitude = approx(rhs, precision)
		 in
		  floor(lhs') = floor(rhs');

------------------------------------------------------------------------------------
--@section Useful conversions
------------------------------------------------------------------------------------
	
	--@doc miles per hour in BIS to metre per second in SI
	--@doc if want kilometres per hour, need to create a new MeasurementSystem on KPH
	mph2mps: Magnitude -> Magnitude
	mph2mps(mph) ==	mag(metrify(scaleMS(mph, BIS_MILE_PER_HOUR())));
	
------------------------------------------------------------------------------------
--@section Theorems between measurement systems from Isabelle proofs for sense check
------------------------------------------------------------------------------------
	refl_bool: bool -> bool
	refl_bool(x) == x; 

	MEASUREMENT_SYSTEMS: () -> set1 of MeasurementSystem 
	MEASUREMENT_SYSTEMS() ==
			 {SI_ASTRONOMICAL(), SI_DEGREE(), SI_LITRE(), SI_TONNE(), SI_YARD(), SI_FOOT(), 
			  SI_INCH(), SI_MILE(), SI_NAUTICAL_MILE(), SI_POUND(), SI_OUNCE(), SI_STONE(), 
			  SI_KNOT(), SI_MPH(), SI_MPS(), SI_KPH(), SI_PINT(), SI_GALLON(), BIS_FOOT(), 
			  BIS_INCH(), BIS_MILE(), BIS_ACRE(), BIS_OUNCE(), BIS_GALLON(), BIS_PINT(), 
			  BIS_MILE_PER_HOUR(), hDAY(), hWEEK(), hAVG_MONTH(), hYEAR(), wDAY(), wAVG_MONTH()
			 };
			 
	CONVERSION_SCHEMAS : () -> set1 of ConversionSchema
	CONVERSION_SCHEMAS() == {SI, BIS, MHC, MDC, MWC};
	
	DIMENSION_VECTORS  : () -> set1 of DimensionlessVector  
	DIMENSION_VECTORS() == 
			 {DLENGTH, DMASS, DTIME, DCURRENT, DTEMP, DAMOUNT, DINTENSITY, DAREA, 
				DVOLUME, DFREQUENCY, DVELOCITY, DACCELERATION, DENERGY, DPOWER, DFORCE, 
				DPRESSURE, DCHARGE, DPDIFFERENCE, DCAPACITANCE	, DWATT, DRADIAN, DSTERADIAN 
			 }
	post 
		is_(RESULT \ {DRADIAN, DSTERADIAN}, set1 of DimensionVector);
			 
	MAGNITUDES: () -> set1 of Magnitude
	MAGNITUDES() == { 10, 20, 30, 40, 100, centi(100), kilo(10), pico(1), deci(10) };

traces
------------------------------------------------------------------------------------
--@todo
--@subsection Measurement equiv and comparison lemmas (ISQProof.thy, ISQQuantities.thy)
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
--@todo
--@subsection Measurement equiv and comparison lemmas (ISQProof.thy, ISQQuantities.thy)
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
--@subsection Conversion lemmas (ISQConversion.thy)
------------------------------------------------------------------------------------

	--@doc qconv cid x = x; 32 tests
	ISQ_C_id: let ms in set MEASUREMENT_SYSTEMS() in
					(refl_bool(ms_quant_conv(CONV_ID, ms) = ms));
	
	--@doc qconv (c1 o c2) x = qconv c1 (qconv c2 x); 640 tests
	ISQ_C_comp: let ms in set MEASUREMENT_SYSTEMS() in 
								let c1 in set CONVERSION_SCHEMAS() in
									let c2 in set CONVERSION_SCHEMAS() \ {c1} in 
										refl_bool(
										ms_quant_conv(conv_comp(c1, c2), ms) 
										= 
										ms_quant_conv(c1, ms_quant_conv(c2, ms))
										);

	--@doc qconv (1/c o c) x = x; 160 tests									
	ISQ_C_inv: let ms in set MEASUREMENT_SYSTEMS() in 
							 let c in set CONVERSION_SCHEMAS() in
							 		refl_bool(
							 			ms_quant_conv(conv_inv(c), ms_quant_conv(c, ms)) 
							 			= 
							 			ms
							 		);

	--@doc 1280 tests						 		
	ISQ_C_scalQ: let ms in set MEASUREMENT_SYSTEMS() in 
							   let c in set CONVERSION_SCHEMAS() in
							   	 let d in set MAGNITUDES() in
							 	  	refl_bool(
							 	  		ms_quant_conv(c, scaleMS(d, ms)) 
							 	  		= 
							 	  		scaleMS(d, ms_quant_conv(c, ms))
							 	  	);
							 		
------------------------------------------------------------------------------------
--@todo
--@subsection Various other SI lemmas (SI_Constants.thy, SI_Derived, SI_Accepted, 
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
--@subsection SI_Accepted
------------------------------------------------------------------------------------
	--@doc 1 hour = 3600 sec; 1 test
	SIA_1: let
					 lhs: Magnitude = mag(hour(SI, SI_UNIT)),
					 rhs: Magnitude = mag(scaleMS(3600, second(SI, SI_UNIT)))
				 in
				  refl_bool(lhs = rhs);
	--@doc watt/hour = 3600 joule; 1 test
	SIA_2: let
					 lhs: MeasurementSystem = ms_times(SI_WATT, hour(SI, SI_UNIT)),
					 rhs: MeasurementSystem = scaleMS(3600, SI_JOULE())
				 in
				  refl_bool(lhs = rhs);
  --@doc 25 m/s = 90 km/hr; 1 test
	SIA_3: let
					 lhs: Magnitude = mag(scaleMS(25, SI_MPS())),
					 rhs: Magnitude = mag(scaleMS(90, SI_KPH()))
				 in
				  refl_bool(lhs = rhs);
												
------------------------------------------------------------------------------------
--@subsection SI_Prefix
------------------------------------------------------------------------------------
	--@doc 2.3 (centi *q metre)**3 = pico(2.3) * metre^3; 1 test
	SIP_1: let
					 lhs: Magnitude = mag(scaleMS(2.3, ms_itself_n(centi(METER),3))),
					 rhs: Magnitude = mag(scaleMS(pico(2.3), ms_itself_n(METER, 3)))
				 in
				  refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));
	--@doc 1 (centi *q metre)**-1 = 100 * metre**-1
	SIP_2: let
					 lhs: Magnitude = mag(ms_inv(centi(METER))),
					 rhs: Magnitude = mag(scaleMS(100, ms_inv(METER)))
				 in
				  refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));
				  
------------------------------------------------------------------------------------
--@subsection SI Imperial 
------------------------------------------------------------------------------------
	--@doc 1 mile = 5280 feet in SI's view up to some order of magnitude but not others
	SIBIS_1: let
						 lhs: Magnitude = mag(SI_MILE()),
						 rhs: Magnitude = mag(scaleMS(5280, SI_FOOT()))
						in
						 refl_bool(approx_eq(lhs, rhs, 2) and not approx_eq(lhs, rhs, 3));
	--@doc 1 mph = 1.609344 kph in SI; but if we want more generally, create a MS for KPH (like CGS)
	SIBIS_2: let
					 	 lhs: Magnitude = mag(SI_MPH()),
						 rhs: Magnitude = mag(scaleMS(1.609344, SI_KPH()))
						in
						 refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));						 
------------------------------------------------------------------------------------
--@subsection BIS 
------------------------------------------------------------------------------------
	--@doc 1yard ~= 0.914 metres
	BIS_0: refl_bool(mag(metrify(BIS_YARD)) = 0.9143993);

	--@doc lhs = magnitude of a BIS foot in SI,
	--		 rhs = magnitude of 1/3 of BIS yard in SI
	--		 test= metrify(1 foot) = metrify(1 yard) / (3 * metre)
	BIS_1: let
					lhs: Magnitude = mag(metrify(BIS_FOOT())),
					rhs: Magnitude = mag(metrify(BIS_YARD).mag) / (3 * mag(METER))
				in   
					refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));

	--@doc lhs = magnitude of a BIS 70mph in SI metre per second
	--		 rhs = magnitude of particular factor in SI metre per second
	BIS_2: let
					lhs: Magnitude = mph2mps(70),
					rhs: Magnitude = mag(scaleMS((704087461 / 22500000), SI_MPS()))
				in   
					refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));

	--@doc lhs = magnitude of 1 centimetre in CGS as a BIS yard
	--		 rhs = magnitude of BIS yard by given factor 
	BIS_3: let
					lhs: Magnitude = mag(imperialise(scaleMS(1, CENTIMETRE))), 
					rhs: Magnitude = mag(scaleMS(100000 / 9143993, BIS_YARD))
				in   
					refl_bool(approx_eq(lhs, rhs, ORDER_MAGNITUDE));
  					
------------------------------------------------------------------------------------
--@subsection CGS
------------------------------------------------------------------------------------
	--@doc 1KM in SI = 100000 centimetres in CGS
	CGS_1: let 
					 lhs: Magnitude = mag(ms_conv(/*SI, CGS, kilo(METER)*/kilo(METER), CGS)),
					 rhs: Magnitude = mag(scaleMS(100000, CENTIMETRE))
				 in
					 refl_bool((lhs = 100000) and (lhs = rhs));

	--@doc 100 cm in CGS = 1 metre in SI
	CGS_2: refl_bool(mag(metrify(scaleMS(100, CENTIMETRE))) = mag(METER));

------------------------------------------------------------------------------------
--@subsection MHC, MDC, MWC
------------------------------------------------------------------------------------
	--@doc (in hours) week / avg_month = week / year * avg_month / year
	MHC_1: let
					 lhs: MeasurementSystem = hW2M(),
					 rhs: MeasurementSystem = ms_div(ms_div(hWEEK(), hYEAR()), ms_div(hAVG_MONTH(), hYEAR()))
					in
						refl_bool(lhs = rhs);

	--@doc 4 weeks = 0.9438202247191011 avg_month
	MWC_1: let
					 lhs: MeasurementSystem = weeks2months_wks(4),
					 rhs: MeasurementSystem = scaleMS(0.9438202247191011, wAVG_MONTH())
					in
						refl_bool(lhs = rhs);
	
	--@doc 12 weeks = 84 days
	MWC_2: let
					 lhs: MeasurementSystem = scaleMS(12, MWEEK),
					 rhs: MeasurementSystem = scaleMS(84, MDAY)
					in
						refl_bool(mag(ms_conv(lhs, MDC)) = mag(rhs)); 					
------------------------------------------------------------------------------------
--@subsection Other; total 2132 tests
------------------------------------------------------------------------------------

	--@doc 1KM = 1093.614 yards
	T1: refl_bool(imperialise(kilo(METER)).mag = 1093.6141355313812);

	--@doc 1yard = 0.914 metres
	T2: refl_bool(metrify(BIS_YARD).mag = 0.9143993);

	--@doc 1000g = 2.20462 pounds
	T4: refl_bool(mag(ms_conv(/*CGS, BIS, kilo(GRAM)*/kilo(GRAM), BIS)) = 2.2046227773803357);

end ISQ