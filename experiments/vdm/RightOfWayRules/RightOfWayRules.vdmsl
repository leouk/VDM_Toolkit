--@doc Leo Freitas, Copyright 2023
--     Model of "right of way" rules for aircraft
--     follows the ideas in https://link.springer.com/chapter/10.1007/978-3-031-20872-0_4 
module RightOfWayRules
imports from MATH functions atan renamed atan;
exports all
definitions

types   
    --@doc non-zero real
    nzreal = real 
    inv r == r <> 0;

    --@doc positive real
    preal = real 
    inv r == r >= 0;

    --@doc negative real
    nreal = real 
    inv r == r <= 0; 

    --@doc positive non-zero (>0) real
    pnzreal = preal 
    inv r == is_nzreal(r); 

    --@doc negative non-zero (<0) real
    nnzreal = nreal 
    inv r == is_nzreal(r); 

    RVector = real * real; 

    Position = RVector; 

    --@doc plane velocity
    Velocity = nzreal * nzreal; 

    Aircraft ::
        position: Position
        velocity: Velocity; 

    Angle = real 
    inv a == a <= 360;

values 
    DEFAULT_SQRT_ERROR: pnzreal = 0.000001;

functions 
    
	newton_guess: nat * pnzreal -> pnzreal
	newton_guess(value, guess) ==
		(guess + (value / guess)) / 2
    post 
        (2 * RESULT - guess) * guess < value;

	sqrt0: nat * preal * pnzreal * preal -> preal
	sqrt0(valueI, value, err, result) ==
		if (abs (value - result) >= err * value) then
			sqrt0(valueI, result, err, newton_guess(valueI,result))
		else
			result
	pre
		value <= valueI
		and
		err <= valueI
    post 
        RESULT < value
    measure 
        result;

	sqrt: preal * pnzreal -> preal
	sqrt(value, err) == 
		sqrt0(value, value, err, newton_guess(value, value))
	pre
        err <= value 
	post
		--@OnFail("Error tolerance is too big (i.e. reduce err), RESULT=%1s, err=%2s, input=%3s", RESULT, err, value)
		((RESULT * RESULT) - err <= value)
		and
		--@OnFail("Result precision is too coarse (i.e. incorrect algoritm), RESULT=%1s, input=%2s", RESULT, value)
		((RESULT + 1) * (RESULT + 1) > value)
		;

    magnitude: RVector -> preal  
    magnitude(mk_(x, y)) == sqrt(x**2 + y**2, DEFAULT_SQRT_ERROR);

    sum: RVector * RVector -> RVector 
    sum(mk_(x1, y1), mk_(x2, y2)) == mk_(x1+x2, y1+y2);

    minus: RVector -> RVector 
    minus(mk_(x, y)) == mk_(-x, -y);

    sub: RVector * RVector -> RVector
    sub(x, y) == sum(x, minus(y)); 

    rotate90: RVector -> RVector 
    rotate90(mk_(vx, vy)) == mk_(vy, -vx);

    dot_product: RVector * RVector -> real 
    dot_product(mk_(vx1, vy1), mk_(vx2, vy2)) == 
        (vx1*vx2) + (vy1*vy2);

    scalar_product: real * RVector -> RVector
    scalar_product(v, mk_(x,y)) == mk_(v*x, v*y); 

    --@doc Aircraft quadrants (Q1..Q4) on the flight (2D) plane
    Q1: Aircraft * Position -> bool 
    Q1(mk_Aircraft(s0, v0), s1) == 
        let psub: Position = sub(s1, s0) in 
            dot_product(psub, rotate90(v0)) > 0
            and
            dot_product(psub, v0) >= 0
    post 
        to_the_right_of(mk_Aircraft(s0, v0), s1);

    Q2: Aircraft * Position -> bool 
    Q2(mk_Aircraft(s0, v0), s1) == 
        let psub: Position = sub(s1, s0) in 
            dot_product(psub, rotate90(v0)) <= 0
            and
            dot_product(psub, v0) > 0;

    Q3: Aircraft * Position -> bool 
    Q3(mk_Aircraft(s0, v0), s1) == 
        let psub: Position = sub(s1, s0) in 
            dot_product(psub, rotate90(v0)) < 0
            and
            dot_product(psub, v0) <= 0
    post 
        to_the_left_of(mk_Aircraft(s0, v0), s1);

    Q4: Aircraft * Position -> bool 
    Q4(mk_Aircraft(s0, v0), s1) == 
        let psub: Position = sub(s1, s0) in 
            dot_product(psub, rotate90(v0)) >= 0
            and
            dot_product(psub, v0) < 0;

    --@doc Aircrafrt track (i.e. angle between north and aircraft directon)
    track: Aircraft -> Angle 
    track(mk_Aircraft(-, mk_(v0x, v0y))) == 
        atan(v0x / v0y);

    --@doc Time to Closest Point of Approach
    tCPA: Aircraft * Aircraft -> nreal 
    tCPA(mk_Aircraft(s0, v0), mk_Aircraft(s1, v1)) ==
        if v0 = v1 then 
            0
        else 
            let sub_v0v1: Velocity = sub(v0, v1) in
                - (dot_product(sub(s0, s1), sub_v0v1) / dot_product(sub_v0v1, sub_v0v1))
    post 
        v0 <> v1 <=> is_nnzreal(RESULT);  

    --@doc Horizontal Miss Distance is the distance at the Closest Point of Approach 
    --     when their position and velocity vectors are projected in time.
    HMD: Aircraft * Aircraft -> real 
    HMD(mk_Aircraft(s0, v0), mk_Aircraft(s1, v1)) == 
        magnitude(
            sum(
                sub(s0, s1), 
                scalar_product(
                    tCPA(mk_Aircraft(s0, v0), mk_Aircraft(s1, v1)), 
                    sub(v0, v1)
                ) 
            )
        );

    --@doc aircraft relative position 
    to_the_left_of: Aircraft * Position -> bool 
    to_the_left_of(mk_Aircraft(s0, v0), s1) ==
        dot_product(sub(s1, s0), rotate90(v0)) < 0;

    --@doc aircraft relative position 
    to_the_right_of: Aircraft * Position -> bool 
    to_the_right_of(mk_Aircraft(s0, v0), s1) ==
        dot_product(sub(s1, s0), rotate90(v0)) > 0;

    --@doc aircraft relative motion
    left_to_right: Aircraft * Aircraft -> bool 
    left_to_right(mk_Aircraft(-, v0), mk_Aircraft(-, v1)) == 
        dot_product(v0, v1) < 0;

    --@doc aircraft relative motion
    right_to_left: Aircraft * Aircraft -> bool 
    right_to_left(mk_Aircraft(-, v0), mk_Aircraft(-, v1)) == 
        dot_product(v0, v1) > 0;

    --@doc Check trajectories will cross in future
    going_to_cross: Aircraft * Aircraft -> bool 
    going_to_cross(a0, a1) == 
        (to_the_left_of(a0, a1.position) and left_to_right(a0, a1))
        or
        (to_the_right_of(a0, a1.position) and right_to_left(a0, a1));

    --@doc Check trajectories have already crossed
    crossed: Aircraft * Aircraft -> bool 
    crossed(a0, a1) == 
        (to_the_left_of(a0, a1.position) and right_to_left(a0, a1))
        or
        (to_the_right_of(a0, a1.position) and left_to_right(a0, a1));

    --@doc Check trajectories are going to cross but have not yet crossed
    zero_crossed: Aircraft * Aircraft -> bool 
    zero_crossed(a0, a1) == 
        going_to_cross(a0, a1) and 
        going_to_cross(a1, a0)
    post 
        RESULT <=> not crossed(a0, a1);
        
    --@doc One aircraft (a0) has crossed trajectory of other (a1) but not other way round
    one_crossed: Aircraft * Aircraft -> bool 
    one_crossed(a0, a1) == 
        (going_to_cross(a0, a1) and crossed(a0, a1))
        or 
        (going_to_cross(a1, a0) and crossed(a1, a0));

    --@doc both aircraft crossed each other's trajectories
    both_crossed: Aircraft * Aircraft -> bool 
    both_crossed(a0, a1) == 
        crossed(a0, a1) and crossed(a1, a0);

    --@doc 
    parallel: Aircraft * Aircraft -> bool 
    parallel(a0, a1) == 
        dot_product(a0.velocity, rotate90(a1.velocity)) = 0;

    same_orientation: Aircraft * Aircraft -> bool 
    same_orientation(a0, a1) == 
        dot_product(a0.velocity, rotate90(a1.velocity)) > 0;

    opposite_orientation: Aircraft * Aircraft -> bool 
    opposite_orientation(a0, a1) == 
        dot_product(a0.velocity, rotate90(a1.velocity)) < 0;

    IS_in_q1_and_was_in_q2: Aircraft * Aircraft -> bool
    IS_in_q1_and_was_in_q2(a0, a1) == 
        (Q1(a0, a1.position) and Q4(a1, a0.position))
        or
        (opposite_orientation(a0, a1) and left_to_right(a0, a1));

    QC: Aircraft * Aircraft -> bool 
    QC(a0, a1) == 
        (Q1(a0, a1.position) and Q1(a1, a0.position))
        or
        (Q2(a0, a1.position) and Q2(a1, a0.position))
        or
        (Q3(a0, a1.position) and Q3(a1, a0.position))
        or
        (Q4(a0, a1.position) and Q4(a1, a0.position));

    converging: Aircraft * Aircraft -> preal -> bool
    converging(a0, a1)(delta_c) == 
        QC(a0, a1) and (HMD(a0, a1) < delta_c);

    conv_not_headon: Aircraft * Aircraft -> preal * Angle -> bool 
    conv_not_headon(a0, a1)(delta_c, Delta_h) == 
        converging(a0, a1)(delta_c)
        and 
        (
        let track_delta: Angle/*or nat? */ = 
                abs (track(a0) - track(a1))
        in
             (180 + Delta_h < track_delta)
             or 
             (track_delta < 180 - Delta_h)
        );

    headon: Aircraft * Aircraft -> preal * Angle -> bool 
    headon(a0, a1)(delta_c, Delta_h) == 
        converging(a0, a1)(delta_c)
        and 
        (
        let track_delta: Angle/*or nat? */ = 
                abs (track(a0) - track(a1))
        in
             (180 - Delta_h <= track_delta)
             and 
             (track_delta < 180 + Delta_h)
        );

    overtaking: Aircraft * Aircraft -> preal -> bool 
    overtaking(a0, a1)(delta_o) == 
        (Q1(a0, a1.position) or Q2(a0, a1.position))
        and 
        (Q3(a1, a0.position) or Q4(a1, a0.position))
        and 
        (HMD(a0, a1) < delta_o);

    right_of_way: Aircraft * Aircraft -> preal * preal * preal -> bool 
    right_of_way(a0, a1)(delta_o, delta_c, Delta_h) == 
        overtaking(a0, a1)(delta_o)
        or 
        (conv_not_headon(a0, a1)(delta_c, Delta_h)
         and 
         to_the_right_of(a0, a1.position)
         and
         zero_crossed(a0, a1)
        );

    --@doc Safety 1: no two aircraft can share right of way
    theorem1: Aircraft * Aircraft -> preal * preal * preal -> bool 
    theorem1(a0, a1)(delta_o, delta_c, Delta_h) == 
        right_of_way(a1, a0)(delta_o, delta_c, Delta_h)
        => 
        not right_of_way(a0, a1)(delta_o, delta_c, Delta_h);

    --@doc Safety 1a: if two aircraft have not crossed trajectories, then only one is to right of the other
    theorem2: Aircraft * Aircraft -> bool 
    theorem2(a0, a1) == 
        zero_crossed(a1, a0)
        =>
        ((to_the_right_of(a0, a1.position) 
          and 
          not to_the_right_of(a1, a0.position)
         )
         or
         (to_the_right_of(a1, a0.position) 
          and 
          not to_the_right_of(a0, a1.position)
         )
        );

    --@doc Overtaking is assymetric 
    theorem3: Aircraft * Aircraft -> preal -> bool 
    theorem3(a0, a1)(delta_o) == 
        overtaking(a0, a1)(delta_o) => not overtaking(a1, a0)(delta_o);

    --@doc No right-of-way after crossing
    theorem4: Aircraft * Aircraft -> bool 
    theorem4(a0, a1) == 
        one_crossed(a0, a1)
        =>
        ((to_the_right_of(a0, a1.position) 
          and 
          to_the_right_of(a1, a0.position)
         )
         or 
         (to_the_left_of(a0, a1.position) 
          and 
          to_the_left_of(a1, a0.position)
         )
        );

    --@doc Aircraft awareness
    theorem5: Aircraft * Aircraft -> preal * preal * preal -> bool 
    theorem5(a0, a1)(delta_o, delta_c, Delta_h) == 
        conv_not_headon(a0, a1)(delta_c, Delta_h)
        =>
        (zero_crossed(a0, a1) and to_the_left_of(a0, a1.position)
         =>
         right_of_way(a1, a0)(delta_o, delta_c, Delta_h)
        );

    --@doc Had right of way
    theorem6: Aircraft * Aircraft -> bool 
    theorem6(a0, a1) == 
        Q1(a0, a1.position) and Q1(a1, a0.position) and not parallel(a0, a1)
        =>
        (IS_in_q1_and_was_in_q2(a0, a1) or IS_in_q1_and_was_in_q2(a1, a0));

end RightOfWayRules