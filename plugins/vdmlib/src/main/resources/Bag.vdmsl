------------------------------------------------------------------------------------
--@header 
--@doc Copyright Leo Freitas 2019-2023 
--@doc Bag as an abstract data type (inspired by SPARK ADTs and Z/Eves bags)
------------------------------------------------------------------------------------
module Bag 
exports 
    types 
        Bag;
    functions 
        empty: () -> Bag;  
        isEmpty: Bag -> bool;  
        bset[@T]: Bag -> set of @T;
        inbag[@T]: @T * Bag -> bool;
        count[@T]: Bag -> (@T -> nat);
        amount[@T]: Bag * @T -> nat;
        post_amount[@T]: Bag * @T * nat +> bool;
        subbageq[@T]: Bag * Bag -> bool;
        scale[@T]: nat * Bag -> Bag;
        bunion[@T]: Bag * Bag -> Bag;
        post_bunion[@T]: Bag * Bag * Bag +> bool;
        difference[@T]: Bag * Bag -> Bag;
        post_difference[@T]: Bag * Bag * Bag +> bool;
        items[@T]: seq of @T -> Bag;
        --@todo if we have @T, these aren't needed? 
        type_test[@T]: () -> (? -> bool);
        type_convergent[@T]: Bag -> bool;
definitions
types 
    Bag = map ? to nat1;

functions 
    empty: () -> Bag
    empty() == {|->};

    isEmpty: Bag -> bool 
    isEmpty(b) == b = empty()
    post 
        RESULT <=> b = empty();

    --@QuickCheck @T = nat
    bset[@T]: Bag -> set of @T
    bset(b) == dom b;

    --@QuickCheck @T = nat
    inbag[@T]: @T * Bag -> bool    
    inbag(x, b) == x in set bset[@T](b)
    pre 
        type_convergent[@T](b)
    post 
        RESULT <=> x in set bset[@T](b);

    --@QuickCheck @T = nat
    count[@T]: Bag -> (@T -> nat)
    count(b) == (lambda x: @T & amount[@T](b, x));

    --@QuickCheck @T = nat
    amount[@T]: Bag * @T -> nat 
    amount(b, x) == 
        if inbag[@T](x, b) then b(x) else 0
    post 
        (inbag[@T](x, b) <=> is_nat1(RESULT));

    --@QuickCheck @T = nat
    subbageq[@T]: Bag * Bag -> bool
    subbageq(a, b) ==
        forall xa in set dom a & amount[@T](a, a(xa)) <= amount[@T](b, b(xa))
    post 
        bset[@T](a) subset bset[@T](b);

    --@doc ZEves scale definition is wrong! wrt to theorem bagscaleBy1 (!
    --@QuickCheck @T = nat
    scale[@T]: nat * Bag -> Bag 
    scale(n, b) == 
        if n = 0 then 
            empty() 
        else  
            { x |-> n * b(x) | x in set dom b };

    --@QuickCheck @T = nat
    bunion[@T]: Bag * Bag -> Bag 
    bunion(a, b) == 
        { x |-> a(x) + b(x) | x in set dom a union dom b }
    post 
        bset[@T](RESULT) = bset[@T](a) union bset[@T](b);

    --@QuickCheck @T = nat
    difference[@T]: Bag * Bag -> Bag 
    difference(a, b) == 
        { x |-> a(x) - b(x) | x in set dom a union dom b /*inter dom b*/ & a(x) - b(x) > 0 }
    post 
        --@doc not equal because when zeroed it goes out of the domain
        bset[@T](RESULT) subset bset[@T](a) \ bset[@T](b);

    --@QuickCheck @T = nat
    filter[@T]: seq of @T * (@T -> bool) -> seq of @T 
    filter(s, f) == [ s(i) | i in set inds s & f(s(i)) ]
    post 
        RESULT <> [] <=> (forall x in set elems RESULT & f(x)); -- RESULT <> [] <=> elems RESULT = {x};

    --@QuickCheck @T = nat
    items[@T]: seq of @T -> Bag 
    items(s) == { s(i) |-> len filter[@T](s, (lambda x: @T & s(i) = x)) | i in set inds s }
    post 
        elems s = bset[@T](RESULT);

    --@QuickCheck @T = nat
	type_test[@T]: () -> (? -> bool)
	type_test() == (lambda t: ? & is_(t, @T));

	--@doc all elements of the bag are type convergent up to @T
    --@QuickCheck @T = nat
	type_convergent[@T]: Bag -> bool
	type_convergent(b) == 
		forall i in set dom b & type_test[@T]()(i);

end Bag