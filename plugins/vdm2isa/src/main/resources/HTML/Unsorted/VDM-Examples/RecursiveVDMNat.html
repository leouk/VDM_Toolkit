<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory RecursiveVDMNat</title>
</head>


<body>
<div class="head">
<h1>Theory RecursiveVDMNat</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><span>RecursiveVDMNat</span><span>
  </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="VDMToolkit.html"><span>VDMToolkit</span></a><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>
primrec 
  isafact :: "‚Ñï ‚áí ‚Ñï" 
  where 
  "isafact n = 
      (if n = 0 then 1 else n * (isafact (n-1)))" </span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.isafact.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact_def|fact"><span class="entity_def" id="RecursiveVDMNat.isafact.simps(2)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact.simps(1)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact_def|thm"><span class="entity_def" id="RecursiveVDMNat.isafact_def|axiom"><span>primrec</span></span></span></span></span></span></span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.isafact|const"><span>isafact</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>"</span></span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>isafact</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>1</span></span><span>"</span></span></span><span> 
</span><span class="main"><span>|</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>isafact</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="free"><span>isafact</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>print_theorems</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.elims|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.pelims|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.termination|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.pinduct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.psimps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.intros|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.intros|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.elims|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.simps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.pelims|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.termination|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.pinduct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;.psimps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.simps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel.intros|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.simps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph.intros|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_sumC_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_dom|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_rel|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_sumC|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;_graph|const"><span>fun</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;|const"><span>isafact'</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>"</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>isafact'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>1</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>isafact'</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>print_theorems</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.elims|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.pelims|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.termination|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.pinduct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.psimps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.intros|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.simps|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.induct|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.cases|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.intros|fact"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.elims|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.simps(2)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.simps(1)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.pelims|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.termination|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.pinduct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.psimps(2)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;.psimps(1)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.simps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel.intros|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.simps|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.induct|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.cases|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.intros(2)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph.intros(1)|thm"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_sumC_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph_def|axiom"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_dom|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_rel|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_sumC|const"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;_graph|const"><span>fun</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.isafact&apos;&apos;|const"><span>isafact''</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>"</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>isafact''</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>1</span></span><span>"</span></span></span><span> 
</span><span class="main"><span>|</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>isafact''</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>isafact''</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>print_theorems</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>VDM expressions with basic-typed (nat, int) variables (e.g. </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="free"><span>x</span></span><span class="main"><span>-</span></span><span class="free"><span>y</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>)
</span><span>  have specific type widening rules (e.g. if both variables are nat, the result might be int).
</span><span>  Therefore, in Isabelle VDM nats become </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a></span><span class="antiquote"><span>}</span></span></span><span>, which are just a synonym for </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñ§</span></span></span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>  Isabelle recursive functions requires a proof obligation that parameters represent a 
</span><span>  constructive and compatible pattern, and that recursive calls terminate. Nevertheless,
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñ§</span></span></span><span class="antiquote"><span>}</span></span></span><span> in Isabelle is defined in terms of a pair of </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñï</span></span></span><span class="antiquote"><span>}</span></span></span><span>, hence recursion over </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñ§</span></span></span><span class="antiquote"><span>}</span></span></span><span>
</span><span>  are involved. Given VDM needs to represent its nat variables as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a></span><span class="antiquote"><span>}</span></span></span><span> this will make
</span><span>  VDM recursive functions in Isabelle involved as well.
</span><span> 
</span><span>  To give a concrete example, we define a recursive implementation of factorial in VDM 
</span><span>  translated to Isabelle as:
</span><span>
</span><span>  \begin{vdmsl}
</span><span>    factorial: nat -&gt; nat 
</span><span>    factorial(n) == if n = 0 then 1 else n * factorial(n)
</span><span>  	--@IsaMeasure( { (n -1, n) | n : nat &amp; n &lt;&gt; 0 } )
</span><span>    measure n;
</span><span>  \end{vdmsl}
</span><span>
</span><span>  For translation, we firt encode the implicit precondition of factorial that 
</span><span>  insists that the given parameter </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="free"><span>n</span></span></span><span class="antiquote"><span>}</span></span></span><span> is a </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a></span><span class="antiquote"><span>}</span></span></span><span>
</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_def|fact"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_def|thm"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial|const"><span>pre_vdm_factorial</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_vdm_factorial</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_defs|fact"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_defs(2)|thm"><span class="entity_def" id="RecursiveVDMNat.pre_vdm_factorial_defs(1)|thm"><span>pre_vdm_factorial_defs</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.pre_vdm_factorial_def|fact"><span>pre_vdm_factorial_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> 

</span><span class="comment1"><span>(</span><span>*</span><span>
fun (domintros) vdm_factorial' :: ‚ÄπVDMNat ‚áí VDMNat‚Ä∫
  where
  ‚Äπvdm_factorial' n =
    (if pre_vdm_factorial n then
      (if n = 0 then 
        1
      else
        n * (vdm_factorial' (n - 1))
      )
    else
      undefined)‚Ä∫
</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Next, we define the factorial function through recursion, where 
</span><span>      when the precondition fails, we return </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>undefined</span></span><span class="antiquote"><span>}</span></span></span><span>, which is 
</span><span>      a term that cannot be reasoned with in Isabelle (i.e. it's a dead end).
</span><span>      Otherwise, we define factorial pretty much as in VDM.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.domintros|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.pelims|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.cases|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.termination|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.pinduct|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.psimps|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.simps|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.induct|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.cases|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.intros|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.inducts|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.simps|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.induct|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.cases|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.intros|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.domintros|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.pelims|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.cases|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.termination|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.pinduct|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.psimps|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.simps|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.induct|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.cases|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel.intros|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.inducts|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.simps|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.induct|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.cases|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph.intros|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_def|axiom"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel_def|axiom"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_sumC_def|axiom"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph_def|axiom"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_dom|const"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_rel|const"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_sumC|const"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial|const"><span>vdm_factorial</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>vdm_factorial</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.pre_vdm_factorial|const"><span>pre_vdm_factorial</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span>
      </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> 
        </span><span class="main"><span>1</span></span><span>
      </span><span class="keyword1"><span>else</span></span><span>
        </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>vdm_factorial</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span>else</span></span><span>
      </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Pattern compatibility and completeness is discharged with the usual proof strategy in this case.
</span><span>        In the general (more complex recursive call cases, e.g., Ackerman's function for instance), the 
</span><span>        user might have goals to discharge.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Following the same strategy as before for sets, we define a relation representing 
</span><span>  the recursive and original call, respectively. The relation contains only input values 
</span><span>  that satisfy the precondition of factorial as well as the specific case which recursion occurs (e.g. </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>).</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial_wf|const"><span>vdm_factorial_wf</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span>set</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>vdm_factorial_wf</span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.pre_vdm_factorial|const"><span>pre_vdm_factorial</span></a><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>}</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>To make well foundedness proof easy, we reuse an already proved well founded 
</span><span>  relation for the integers, with the relation 
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>int_ge_less_than</span></span><span class="antiquote"><span>}</span></span></span><span>[display] which we start from </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="main"><span>0</span></span></span><span class="antiquote"><span>}</span></span></span><span>, as defined by </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a></span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>  This is quite similar to the strategy used for finite subsets with </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>finite_psubset</span></span><span class="antiquote"><span>}</span></span></span><span>[display].
</span><span>
</span><span>  Because </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>int_ge_less_than</span></span><span class="antiquote"><span>}</span></span></span><span> is already well founded (e.g. </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>wf_int_ge_less_than</span><span class="antiquote"><span>}</span></span></span><span>[display]),
</span><span>  the proof for our definition is trivial.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDMNat.l_vdm_factorial_term_wf|fact"><span class="entity_def" id="RecursiveVDMNat.l_vdm_factorial_term_wf|thm"><span>l_vdm_factorial_term_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span>wf</span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.vdm_factorial_wf|const"><span>vdm_factorial_wf</span></a><span class="main"><span>)</span></span><span>"</span></span></span><span> 
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>wf_int_ge_less_than</span><span> </span><span>wf_Int1</span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>To mak sure our choice is valid (e.g. doesn't lead to the empty relation), we ensure
</span><span>  that indeed the termination relation is in fact the same as the well founded predicate.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDMNat.l_vdm_factorial_term_valid|fact"><span class="entity_def" id="RecursiveVDMNat.l_vdm_factorial_term_valid|thm"><span>l_vdm_factorial_term_valid</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.vdm_factorial_wf|const"><span>vdm_factorial_wf</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.vdm_factorial_wf|const"><span>vdm_factorial_wf</span></a><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.pre_vdm_factorial_defs|fact"><span>pre_vdm_factorial_defs</span></a><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="main"><span>)</span></span><span>
   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp_all</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>int_ge_less_than_def</span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>auto</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, we prove termination using the previously proved lemmas using the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>relation</span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>  This simplifies the goal into well formedness of termination relation and that the precondition implies it,
</span><span>  both of which are easily proved with simplification in this case.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.elims|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.induct|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.simps|fact"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.elims|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.induct|thm"><span class="entity_def" id="RecursiveVDMNat.vdm_factorial.simps|thm"><span>termination</span></span></span></span></span></span></span></span></span><span> 
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>relation</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.vdm_factorial_wf|const"><span>vdm_factorial_wf</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.l_vdm_factorial_term_wf|fact"><span>l_vdm_factorial_term_wf</span></a><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>presburger</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDMNat.html#RecursiveVDMNat.pre_vdm_factorial_defs|fact"><span>pre_vdm_factorial_defs</span></a><span> </span><span>int_ge_less_than_def</span><span class="main"><span>)</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span></pre>
</body>

</html>