<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory RecursiveSet</title>
</head>


<body>
<div class="head">
<h1>Theory RecursiveSet</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><span>RecursiveSet</span><span>
  </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="VDMToolkit.html"><span>VDMToolkit</span></a><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursive partial recursive functions</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>In Isabelle, recursive functions must discharge proof obligations on:</span><span>

</span><span>    </span><span class="antiquoted"><span>‚ñ∏</span></span><span>  </span><span>pattern completeness: </span><span>

        </span><span>This relates to all patterns in a constructive type</span><span>
        </span><span>being refered to (e.g., </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="main"><span>0</span></span></span><span class="antiquote"><span>}</span></span></span><span> and </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span> for </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñï</span></span></span><span class="antiquote"><span>}</span></span></span><span>)).</span><span>
  
</span><span>    </span><span class="antiquoted"><span>‚ñ∏</span></span><span> </span><span>pattern compatibility:</span><span>
  
        </span><span>This relates to multiple way patterns can be constructed that boils</span><span>
        </span><span>down to the pattern completeness cases (e.g., </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="free"><span>n</span></span><span> </span><span class="main"><span>+</span></span><span> </span><span class="numeral"><span>2</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span> being </span><span>
        </span><span>simply multiple successor calls over constructors </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="main"><span>0</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>). </span><span>

  </span><span>That is important to ensure that recursion is well structured (i.e., recursive calls will not</span><span>
  </span><span>get stuck because call constructs are not available). For example, if you miss the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="main"><span>0</span></span></span><span class="antiquote"><span>}</span></span></span><span> </span><span>
  </span><span>case, eventually the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span> case will reach zero and fail. </span><span>

  </span><span>A final proof obligation is on termination: the recursion is well-founded. This has to be</span><span>
  </span><span>proved whenever properties of defined function are meant to be total. </span><span>

  </span><span>For example, a function that finds the zero of functions can be given as:</span><span>
</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveSet.findzero.domintros|fact"><span class="entity_def" id="RecursiveSet.findzero.pelims|fact"><span class="entity_def" id="RecursiveSet.findzero.cases|fact"><span class="entity_def" id="RecursiveSet.findzero.termination|fact"><span class="entity_def" id="RecursiveSet.findzero.pinduct|fact"><span class="entity_def" id="RecursiveSet.findzero.psimps|fact"><span class="entity_def" id="RecursiveSet.findzero_rel.inducts|fact"><span class="entity_def" id="RecursiveSet.findzero_rel.simps|fact"><span class="entity_def" id="RecursiveSet.findzero_rel.induct|fact"><span class="entity_def" id="RecursiveSet.findzero_rel.cases|fact"><span class="entity_def" id="RecursiveSet.findzero_rel.intros|fact"><span class="entity_def" id="RecursiveSet.findzero_graph.inducts|fact"><span class="entity_def" id="RecursiveSet.findzero_graph.simps|fact"><span class="entity_def" id="RecursiveSet.findzero_graph.induct|fact"><span class="entity_def" id="RecursiveSet.findzero_graph.cases|fact"><span class="entity_def" id="RecursiveSet.findzero_graph.intros|fact"><span class="entity_def" id="RecursiveSet.findzero.domintros|thm"><span class="entity_def" id="RecursiveSet.findzero.pelims|thm"><span class="entity_def" id="RecursiveSet.findzero.cases|thm"><span class="entity_def" id="RecursiveSet.findzero.termination|thm"><span class="entity_def" id="RecursiveSet.findzero.pinduct|thm"><span class="entity_def" id="RecursiveSet.findzero.psimps|thm"><span class="entity_def" id="RecursiveSet.findzero_rel.inducts|thm"><span class="entity_def" id="RecursiveSet.findzero_rel.simps|thm"><span class="entity_def" id="RecursiveSet.findzero_rel.induct|thm"><span class="entity_def" id="RecursiveSet.findzero_rel.cases|thm"><span class="entity_def" id="RecursiveSet.findzero_rel.intros|thm"><span class="entity_def" id="RecursiveSet.findzero_graph.inducts|thm"><span class="entity_def" id="RecursiveSet.findzero_graph.simps|thm"><span class="entity_def" id="RecursiveSet.findzero_graph.induct|thm"><span class="entity_def" id="RecursiveSet.findzero_graph.cases|thm"><span class="entity_def" id="RecursiveSet.findzero_graph.intros|thm"><span class="entity_def" id="RecursiveSet.findzero_def|axiom"><span class="entity_def" id="RecursiveSet.findzero_rel_def|axiom"><span class="entity_def" id="RecursiveSet.findzero_sumC_def|axiom"><span class="entity_def" id="RecursiveSet.findzero_graph_def|axiom"><span class="entity_def" id="RecursiveSet.findzero_dom|const"><span class="entity_def" id="RecursiveSet.findzero_rel|const"><span class="entity_def" id="RecursiveSet.findzero_sumC|const"><span class="entity_def" id="RecursiveSet.findzero_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveSet.findzero|const"><span>findzero</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span>nat</span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span>nat</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span>nat</span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span>nat</span><span>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
</span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>findzero</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>f</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>f</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span>findzero</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>f</span></span></span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>pat_completeness</span></span><span> </span><span class="operator"><span>auto</span></span><span>

</span><span class="keyword1"><span class="command"><span>print_theorems</span></span></span><span> 

</span><span class="keyword1"><span class="command"><span>term</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero_dom|const"><span>findzero_dom</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>term</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero_rel|const"><span>findzero_rel</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>thm</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero.domintros|fact"><span>findzero.domintros</span></a><span> </span><span>impI</span><span>
    </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero_rel.intros|fact"><span>findzero_rel.intros</span></a><span>
</span><span class="keyword1"><span class="command"><span>find_theorems</span></span></span><span> name</span><span class="main"><span>:</span></span><span class="quoted"><span>"</span><span>Wellfounded.acc</span><span>"</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Various theorems are made available, such as:
</span><span>
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero.cases|fact"><span>findzero.cases</span></a><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>  Cases analysis
</span><span>
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero.pelims|fact"><span>findzero.pelims</span></a><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>  Elimination rules 
</span><span>
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero.pinduct|fact"><span>findzero.pinduct</span></a><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>  Induction rules
</span><span>
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero.psimps|fact"><span>findzero.psimps</span></a><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>  Simplificaiton rules
</span><span>
</span><span>  Note the last two are partial, module a domain predicate </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.findzero_dom|const"><span>findzero_dom</span></a></span><span class="antiquote"><span>}</span></span></span><span>,
</span><span>  which represents a well-founded relation that ensures termination. These p-rules
</span><span>  can be simplified into total rules that do not depend on a domain predicate, which
</span><span>  can compicate proofs.</span><span>
</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Exampe of recursive functions with non-constructive types</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursing on non-constructive types (e.g., sets, integers, etc.) entail 
</span><span>    more involved compatibility and completeness proofs. They also usually lead to 
</span><span>    partial function definitions, given Isabelle can't tell whether termination is
</span><span>    immediatelly obvious. 
</span><span>
</span><span>    In VDM, however, recursive functions on sets (as well as map domains) are common. 
</span><span>    
</span><span>    In our vdm2isa translator, we impose various implicit VDM checks as explicit predicates
</span><span>    in Isabelle. In VDM, sets are always finite, and structural invariants are declared for types.
</span><span>
</span><span>    Our example recursive function is given a set of </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñï</span></span></span><span class="antiquote"><span>}</span></span></span><span> and return their sum. In VDM,
</span><span>    because of various type widening rules (e.g., </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>0</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>::</span></span><span>nat</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span> returns an integer result, 
</span><span>    whereas in Isabelle this remains a </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñï</span></span></span><span class="antiquote"><span>}</span></span></span><span>.). We encode VDM
</span><span>    corresponding type as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a></span><span class="antiquote"><span>}</span></span></span><span>. This is represented in Isabelle as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>typ</span></span><span> </span><span class="quoted"><span class="main"><span>‚Ñ§</span></span></span><span class="antiquote"><span>}</span></span></span><span> in order 
</span><span>    to allow for VDM type widening rules during translation.
</span><span>
</span><span>    The function is defined in VDM as:
</span><span>
</span><span>    \begin{vdmsl}
</span><span>        sumset: set of nat -&gt; nat 
</span><span>        sumset(s) == if s = {} then 0 else let e in set s in sumset(s - {e}) + e
</span><span>        --@IsaMeasure( { (x - { let e in set x in e }, x) | x : set of nat &amp; x &lt;&gt; {} } ) 
</span><span>        --@Witness({ 1 })
</span><span>        measure card s;
</span><span>    \end{vdmsl}
</span><span>
</span><span>    It consumes the set by picking each set element and summing them to the recursive call until
</span><span>    the set is empty.
</span><span>
</span><span>    In Isabelle, the implicit VDM checks are defined as the precondition, which ensures 
</span><span>    that the given set contains only natural numbers, and is finite.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveSet.pre_sumset_def|fact"><span class="entity_def" id="RecursiveSet.pre_sumset_def|thm"><span class="entity_def" id="RecursiveSet.pre_sumset_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveSet.pre_sumset|const"><span>pre_sumset</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>"</span></span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>pre_sumset</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMSet&apos;|const"><span>inv_VDMSet'</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>These def sets are automatically generated by translator.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveSet.pre_sumset_defs|fact"><span class="entity_def" id="RecursiveSet.pre_sumset_defs(5)|thm"><span class="entity_def" id="RecursiveSet.pre_sumset_defs(4)|thm"><span class="entity_def" id="RecursiveSet.pre_sumset_defs(3)|thm"><span class="entity_def" id="RecursiveSet.pre_sumset_defs(2)|thm"><span class="entity_def" id="RecursiveSet.pre_sumset_defs(1)|thm"><span>pre_sumset_defs</span></span></span></span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset_def|fact"><span>pre_sumset_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMSet&apos;_defs|fact"><span>inv_VDMSet'_defs</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>We define the VDM recursive function in Isabelle next. It checks whether the given
</span><span>      set satisfy the function precondition. If it doesn't, </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>undefined</span></span><span class="antiquote"><span>}</span></span></span><span> is returned.
</span><span>      If it does, then each case is encoded pretty much 1-1 from VDM using Hilbert's choice operator.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveSet.sumset.domintros|fact"><span class="entity_def" id="RecursiveSet.sumset.pelims|fact"><span class="entity_def" id="RecursiveSet.sumset.cases|fact"><span class="entity_def" id="RecursiveSet.sumset.termination|fact"><span class="entity_def" id="RecursiveSet.sumset.pinduct|fact"><span class="entity_def" id="RecursiveSet.sumset.psimps|fact"><span class="entity_def" id="RecursiveSet.sumset_rel.inducts|fact"><span class="entity_def" id="RecursiveSet.sumset_rel.simps|fact"><span class="entity_def" id="RecursiveSet.sumset_rel.induct|fact"><span class="entity_def" id="RecursiveSet.sumset_rel.cases|fact"><span class="entity_def" id="RecursiveSet.sumset_rel.intros|fact"><span class="entity_def" id="RecursiveSet.sumset_graph.inducts|fact"><span class="entity_def" id="RecursiveSet.sumset_graph.simps|fact"><span class="entity_def" id="RecursiveSet.sumset_graph.induct|fact"><span class="entity_def" id="RecursiveSet.sumset_graph.cases|fact"><span class="entity_def" id="RecursiveSet.sumset_graph.intros|fact"><span class="entity_def" id="RecursiveSet.sumset.domintros|thm"><span class="entity_def" id="RecursiveSet.sumset.pelims|thm"><span class="entity_def" id="RecursiveSet.sumset.cases|thm"><span class="entity_def" id="RecursiveSet.sumset.termination|thm"><span class="entity_def" id="RecursiveSet.sumset.pinduct|thm"><span class="entity_def" id="RecursiveSet.sumset.psimps|thm"><span class="entity_def" id="RecursiveSet.sumset_rel.inducts|thm"><span class="entity_def" id="RecursiveSet.sumset_rel.simps|thm"><span class="entity_def" id="RecursiveSet.sumset_rel.induct|thm"><span class="entity_def" id="RecursiveSet.sumset_rel.cases|thm"><span class="entity_def" id="RecursiveSet.sumset_rel.intros|thm"><span class="entity_def" id="RecursiveSet.sumset_graph.inducts|thm"><span class="entity_def" id="RecursiveSet.sumset_graph.simps|thm"><span class="entity_def" id="RecursiveSet.sumset_graph.induct|thm"><span class="entity_def" id="RecursiveSet.sumset_graph.cases|thm"><span class="entity_def" id="RecursiveSet.sumset_graph.intros|thm"><span class="entity_def" id="RecursiveSet.sumset_def|axiom"><span class="entity_def" id="RecursiveSet.sumset_rel_def|axiom"><span class="entity_def" id="RecursiveSet.sumset_sumC_def|axiom"><span class="entity_def" id="RecursiveSet.sumset_graph_def|axiom"><span class="entity_def" id="RecursiveSet.sumset_dom|const"><span class="entity_def" id="RecursiveSet.sumset_rel|const"><span class="entity_def" id="RecursiveSet.sumset_sumC|const"><span class="entity_def" id="RecursiveSet.sumset_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span>
  </span><span class="entity"><span class="entity_def" id="RecursiveSet.sumset|const"><span>sumset</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>"</span></span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>sumset</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> 
    </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> 
        </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>{}</span></span><span> </span><span class="keyword1"><span>then</span></span><span> 
            </span><span class="main"><span>0</span></span><span> 
         </span><span class="keyword1"><span>else</span></span><span> 
            </span><span class="keyword1"><span>let</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="keyword1"><span>in</span></span><span> 
              </span><span class="free"><span>sumset</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="bound"><span>e</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>+</span></span><span> </span><span class="bound"><span>e</span></span><span class="main"><span>)</span></span><span> 
     </span><span class="keyword1"><span>else</span></span><span> 
        </span><span>undefined</span><span>
    </span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The pattern completeness and compatibility goals are given as 
</span><span>        </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>goals</span></span><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>
</span><span>        We follow the ``usual'' proof strategy for this using pat completeness tactic.
</span><span>        For more general examples, if that fails, </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> should be used.</span><span>
       </span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Termination proof is achieved by establishing a well-founded relation associated with 
</span><span>      the function recursive call with respect to its declaration. 
</span><span>
</span><span>    In our case, that is the smaller set after picking </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="free"><span>e</span></span></span><span class="antiquote"><span>}</span></span></span><span> (</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>) 
</span><span>    and the set used at definition, leading to the pairs </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>    We ensure all the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span class="free"><span>s</span></span></span><span class="antiquote"><span>}</span></span></span><span> involved are not empty and satisfy the function precondition (</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset|const"><span>pre_sumset</span></a></span><span class="antiquote"><span>}</span></span></span><span>).
</span><span>
</span><span>    Given this is a simple (non-mutual, single call-site, easy set element choice) recursion, 
</span><span>    thankfully the setup is not as complex to establish well-foundedness. We piggyback on some
</span><span>    Isabelle machinery by using the term:
</span><span>
</span><span>    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>finite_psubset</span></span><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>
</span><span>    It establishes that a relation where the first element is strictly smaller set than the 
</span><span>    second element in the relation pair. This makes the proof of well-foundedness easy for 
</span><span>    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>, which is important in order for translated code be easier to prove.</span><span> 
        </span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span class="main"><span>)</span></span><span> </span><span>set</span><span>"</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>sumset_wf_rel</span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="bound"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>}</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This definition follows the strategy described in \url{https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf}.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Termination requires well-founded relation, so we prove that function </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset|const"><span>sumset</span></a></span><span class="antiquote"><span>}</span></span></span><span> termination 
</span><span>      relation is well-founded using </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>. This is easily proved by reusing 
</span><span>      a well founded relation for finite proper subsets, which are the upper bound
</span><span>      of any well-formed relation we create. This is important for the termination proof of </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset|const"><span>sumset</span></a></span><span class="antiquote"><span>}</span></span></span><span>.</span><span> </span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveSet.l_sumset_rel_wf|fact"><span class="entity_def" id="RecursiveSet.l_sumset_rel_wf|thm"><span>l_sumset_rel_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span>wf</span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.l_gen_set_term_wf|fact"><span>l_gen_set_term_wf</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>blast</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Moreover, once we establish well-foundedness, we need to get to the termination relation
</span><span>      from the filtering predicate defined through the precondition (i.e. the precondition helps
</span><span>      establish the terminating relation). 
</span><span>
</span><span>      In this case, the only needed term for Isabelle to establish termination is set finiteness, 
</span><span>      however, we insist on the whole precondition to ensure that the intended VDM meaning is 
</span><span>      maintained.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveSet.l_pre_sumset_sumset_wf_rel|fact"><span class="entity_def" id="RecursiveSet.l_pre_sumset_sumset_wf_rel|thm"><span>l_pre_sumset_sumset_wf_rel</span></span></span><span class="main"><span>:</span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="free"><span>s</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="free"><span>s</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term_def|fact"><span>gen_set_term_def</span></a><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset_defs|fact"><span>pre_sumset_defs</span></a><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>metis</span></span><span> </span><span>Diff_subset</span><span> </span><span>member_remove</span><span> </span><span>psubsetI</span><span> </span><span>remove_def</span><span> </span><span>some_in_eq</span><span class="main"><span>)</span></span><span>
  
</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This is sub optimal. Lets then show it's the relation (i.e. finite subset trick to
</span><span>make well-founded induction proof easier, does not compromise the wellfounded relation itself).</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveSet.l_sumset_wf_rel_valid|fact"><span class="entity_def" id="RecursiveSet.l_sumset_wf_rel_valid|thm"><span>l_sumset_wf_rel_valid</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span>  </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="main"><span>)</span></span><span>
   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.l_pre_sumset_sumset_wf_rel|fact"><span>l_pre_sumset_sumset_wf_rel</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>blast</span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveSet.sumset.elims|fact"><span class="entity_def" id="RecursiveSet.sumset.induct|fact"><span class="entity_def" id="RecursiveSet.sumset.simps|fact"><span class="entity_def" id="RecursiveSet.sumset.elims|thm"><span class="entity_def" id="RecursiveSet.sumset.induct|thm"><span class="entity_def" id="RecursiveSet.sumset.simps|thm"><span class="entity_def" id="offset_7606..7617">termination</span></span></span></span></span></span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Next, we have to discharge the termination proof, which is given as
</span><span>       </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>goals</span></span><span class="antiquote"><span>}</span></span></span><span>[display]</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveSet.html#offset_7606..7617"><span>termination</span></a><span>"</span></span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>of</span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span class="main"><span>(</span></span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a></a><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a></a><span class="main"><span class="main"><span>)</span></span></span><span>"</span></span></span></span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>We follow the strategy of using the termination relation and well formedness, which
</span><span>       transforms the mysterious/abstract domain predicate into two new subgoals
</span><span>       </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>goals</span></span><span class="antiquote"><span>}</span></span></span><span>[display]
</span><span>
</span><span>       The first goal is direclty discharged with </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.l_sumset_rel_wf|fact"><span>l_sumset_rel_wf</span></a><span class="antiquote"><span>}</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.l_sumset_rel_wf|fact"><span>l_sumset_rel_wf</span></a><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>force</span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, we show that termination relation is entailed by function precondition.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.l_pre_sumset_sumset_wf_rel|fact"><span>l_pre_sumset_sumset_wf_rel</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>presburger</span></span><span> 

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Is the sumset termination relaiton non-trivial? That is, we have some solutions within
</span><span>      the finite subsets representing the recursive wellfounded relation.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveSet.l_sumset_term_not_empty|fact"><span class="entity_def" id="RecursiveSet.l_sumset_term_not_empty|thm"><span>l_sumset_term_not_empty</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>safe</span></span><span>
  </span><span class="keyword1"><span class="command"><span>find_theorems</span></span></span><span> elim</span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>erule</span></span><span> </span><span>equalityE</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>find_theorems</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>‚äÜ</span></span><span> </span><span class="main"><span>_</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>find_theorems</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>_</span></span><span> </span><span class="main"><span>‚äÜ</span></span><span> </span><span class="main"><span>{}</span></span><span>"</span></span></span><span> elim</span><span>
  </span><span class="keyword1"><span class="command"><span>find_theorems</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span class="main"><span>‚äÜ</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>_</span></span><span>"</span></span></span><span> 
  </span><span class="keyword1"><span class="command"><span>thm</span></span></span><span> </span><span>subset_iff_psubset_eq</span><span> </span><span>subset_eq</span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>subset_eq</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This will require a VDM witness</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>erule_tac</span></span><span> x</span><span class="main"><span class="main"><span>=</span></span></span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>{</span></span><span class="main"><span>1</span></span><span class="main"><span>}</span></span><span>"</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span>in</span></span></span></span><span> </span><span>allE</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>auto</span></span><span> </span><span class="quasi_keyword"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveSet.html#RecursiveSet.pre_sumset_defs|fact"><span>pre_sumset_defs</span></a><span class="main"><span>)</span></span><span> 

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span></pre>
</body>

</html>